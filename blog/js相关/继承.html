<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>继承 | 车程一的博客</title>
    <meta name="description" content="车程一的博客">
    <link rel="icon" href="/vue-logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fbf6f8b.css" as="style"><link rel="preload" href="/assets/js/app.7b18d2f0.js" as="script"><link rel="preload" href="/assets/js/7.75a4d63f.js" as="script"><link rel="prefetch" href="/assets/js/10.ea08bc69.js"><link rel="prefetch" href="/assets/js/11.59d62fd9.js"><link rel="prefetch" href="/assets/js/12.426af9d7.js"><link rel="prefetch" href="/assets/js/13.b2bd6144.js"><link rel="prefetch" href="/assets/js/14.1790ff5e.js"><link rel="prefetch" href="/assets/js/15.584f93ea.js"><link rel="prefetch" href="/assets/js/16.659d2a43.js"><link rel="prefetch" href="/assets/js/17.7825b058.js"><link rel="prefetch" href="/assets/js/18.0b08fef9.js"><link rel="prefetch" href="/assets/js/19.c553a9ae.js"><link rel="prefetch" href="/assets/js/2.ef1579f9.js"><link rel="prefetch" href="/assets/js/20.1a95086a.js"><link rel="prefetch" href="/assets/js/21.57c66887.js"><link rel="prefetch" href="/assets/js/22.3570ca0d.js"><link rel="prefetch" href="/assets/js/23.7fe8ebe9.js"><link rel="prefetch" href="/assets/js/24.5c706192.js"><link rel="prefetch" href="/assets/js/25.d8757158.js"><link rel="prefetch" href="/assets/js/26.8399a71b.js"><link rel="prefetch" href="/assets/js/27.4b3a213a.js"><link rel="prefetch" href="/assets/js/28.eb31cdf1.js"><link rel="prefetch" href="/assets/js/29.577144a6.js"><link rel="prefetch" href="/assets/js/3.62eea2c7.js"><link rel="prefetch" href="/assets/js/30.ef956d23.js"><link rel="prefetch" href="/assets/js/31.2e8ab40d.js"><link rel="prefetch" href="/assets/js/32.9d1685a0.js"><link rel="prefetch" href="/assets/js/33.d800be4d.js"><link rel="prefetch" href="/assets/js/34.85d350fe.js"><link rel="prefetch" href="/assets/js/35.1625e166.js"><link rel="prefetch" href="/assets/js/36.5cf7699d.js"><link rel="prefetch" href="/assets/js/37.0437fe8d.js"><link rel="prefetch" href="/assets/js/38.ca058290.js"><link rel="prefetch" href="/assets/js/39.d4f95e20.js"><link rel="prefetch" href="/assets/js/4.91c625b2.js"><link rel="prefetch" href="/assets/js/40.211acfac.js"><link rel="prefetch" href="/assets/js/41.a5df0168.js"><link rel="prefetch" href="/assets/js/42.6318b490.js"><link rel="prefetch" href="/assets/js/43.a6543bac.js"><link rel="prefetch" href="/assets/js/44.b04565e5.js"><link rel="prefetch" href="/assets/js/45.3bb1a5c1.js"><link rel="prefetch" href="/assets/js/46.15ed4362.js"><link rel="prefetch" href="/assets/js/47.e838dcd2.js"><link rel="prefetch" href="/assets/js/48.0a220d6c.js"><link rel="prefetch" href="/assets/js/49.a81b7774.js"><link rel="prefetch" href="/assets/js/5.a6bc510c.js"><link rel="prefetch" href="/assets/js/50.5ae2a1df.js"><link rel="prefetch" href="/assets/js/51.1e50c0a5.js"><link rel="prefetch" href="/assets/js/52.05832c5b.js"><link rel="prefetch" href="/assets/js/6.edf1ab01.js"><link rel="prefetch" href="/assets/js/8.ac427bc7.js"><link rel="prefetch" href="/assets/js/9.7c5ccd0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fbf6f8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">车程一的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>前端实战</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>js相关</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/js相关/js原型链.html" class="sidebar-link">js原型链</a></li><li><a href="/blog/js相关/promise的实现原理.html" class="sidebar-link">promise的实现原理</a></li><li><a href="/blog/js相关/继承.html" class="active sidebar-link">继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js相关/继承.html#借用构造器函数" class="sidebar-link">借用构造器函数</a></li><li class="sidebar-sub-header"><a href="/blog/js相关/继承.html#组合继承" class="sidebar-link">组合继承</a></li><li class="sidebar-sub-header"><a href="/blog/js相关/继承.html#寄生式继承（与原型式继承雷同）" class="sidebar-link">寄生式继承（与原型式继承雷同）</a></li><li class="sidebar-sub-header"><a href="/blog/js相关/继承.html#寄生组合式继承" class="sidebar-link">寄生组合式继承</a></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>react理解</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>总结记录</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构算法</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h1> <p>今天这片文章记录一下js中实现继承的几种方式。</p> <h2 id="借用构造器函数"><a href="#借用构造器函数" aria-hidden="true" class="header-anchor">#</a> 借用构造器函数</h2> <p>借用构造器函数实现继承的方式非常简单：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Sup1</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Sup1<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
			constructor<span class="token punctuation">:</span> Sup1<span class="token punctuation">,</span>
			<span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">function</span> <span class="token function">Sup2</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
			Sup1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>



		<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sup2</span><span class="token punctuation">(</span><span class="token string">'ccy'</span><span class="token punctuation">)</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><p>如以上代码所示，只需要在子类的构造器中调用父类的构造器即可，关键的一点是别忘记使用 <code>call</code>或者 <code>apply</code> 去修改 <code>this</code> 的指向。这种继承的方式不仅简单，而且可以传递参数到父类的构造器中。但是我和生活中所有接触到的事物有着一致性，简单的东西虽然简便，但是往往有着一些不足。当我们到控制台去打印出 <code>obj</code> 这个对象的时候，发现它并不具备  <code>sayName</code> 这个方法。所以这个继承只继承到了父类的构造器的属性，没有继承到父类的原型上的属性。</p> <h2 id="组合继承"><a href="#组合继承" aria-hidden="true" class="header-anchor">#</a> 组合继承</h2> <p>由借用构造器函数的缺陷，可以引出组合继承。既然借用构造器函数的缺陷在于没有继承到原型上的属性，那么在继承的时候在操作一下子类的原型不就可以了么？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Sup1</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
		<span class="token punctuation">}</span>
		Sup1<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
			constructor<span class="token punctuation">:</span> Sup1<span class="token punctuation">,</span>
			<span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
				console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">function</span> <span class="token function">Sup2</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token comment">// 借用构造器函数</span>
			Sup1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		
		Sup2<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sup1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		Sup2<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sup2

		<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sup2</span><span class="token punctuation">(</span><span class="token string">'ccy'</span><span class="token punctuation">)</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
</code></pre></div><p>组合式继承比起借用构造器函数，多做了一点就是使子类的原型等于父类的实例。接下来到控制台查看一下 <code>obj</code>:
<img src="https://s1.ax1x.com/2020/10/29/BJ9JEV.png" alt>
通过原型链的查找，现在 <code>Sup2</code> 的实例也可以使用 <code>Sup1</code> 的 <code>sayName</code> 方法了。而且这样实现继承，<code>Sup2</code> 的实例也可以使用 <code>instanceof</code> 操作符判定是等于 <code>Sup1</code> 的。 似乎已经很好了。但是还是有一点不足。观察 <code>Sup2</code> 的原型，上面有一个 <code>name</code> 属性，由于 <code>Sup2</code> 的原型实际上是 <code>Sup1</code> 的实例，它当然会拥有 <code>name</code> 属性，而且由于在创建实例的时候没有传值，它现在是一个 <code>undefined</code>。</p> <h2 id="寄生式继承（与原型式继承雷同）"><a href="#寄生式继承（与原型式继承雷同）" aria-hidden="true" class="header-anchor">#</a> 寄生式继承（与原型式继承雷同）</h2> <p>先抛开组合式继承的缺陷不去看，刚刚提到的两种方式，都是构造器去继承构造器的方式。可在实际的情况中。肯定会遇到直接去继承一个对象的情况。这种时候该怎么做呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
			<span class="token constant">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj
			<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>
			name<span class="token punctuation">:</span> <span class="token string">'ccy'</span><span class="token punctuation">,</span>
			age<span class="token punctuation">:</span> <span class="token string">'dddd'</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span>
</code></pre></div><p>其实实际的做法就是，新建一个对象，使这个对象的 <code>__proto__</code> 属性指向继承的那个对象。 <code>ECMAScript 5</code> 新增了一个 <code>Object.create</code> 方法，在只传入一个参数的情况下，这里的 <code>object</code> 方法与 <code>Object.create</code> 方法的行为完全一致。
其实我觉得 <code>object</code> 方法的实现下面这样更好一些，这样在控制台打印出对象的时候不会有一个 <code>F</code> 的标志</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token comment">// function F(){}</span>
			<span class="token comment">// F.prototype = obj</span>
			<span class="token comment">// return new F()</span>
			<span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token punctuation">{</span>
				__proto__<span class="token punctuation">:</span> obj
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> ret
		<span class="token punctuation">}</span>
</code></pre></div><h2 id="寄生组合式继承"><a href="#寄生组合式继承" aria-hidden="true" class="header-anchor">#</a> 寄生组合式继承</h2> <p>好了，接下来就到了我认为最完美的一种继承方式，也是 <code>ES6</code> 语法糖 <code>class</code> 实际的方式。</p> <p>在来回顾一下刚刚说到的，组合式继承的缺陷在哪里？ 那就是子类的原型链上多了父类的构造器的属性。寄生组合式继承的名字也显而易见的是将这两种继承方式融合到一起，这种方式相较于组合式继承优化的一点就是，在书写子类的原型的时候使用了寄生式继承。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">extendPrototype</span><span class="token punctuation">(</span>Sub1<span class="token punctuation">,</span> Sub2<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">let</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Sub1<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
			prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub2
			Sub2<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype
		<span class="token punctuation">}</span>

		<span class="token keyword">function</span> <span class="token function">Sub1</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
		<span class="token punctuation">}</span>
		Sub1<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">function</span> <span class="token function">Sub2</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>
			Sub1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
			<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
		<span class="token punctuation">}</span>
		<span class="token function">extendPrototype</span><span class="token punctuation">(</span>Sub1<span class="token punctuation">,</span> Sub2<span class="token punctuation">)</span>
		<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub2</span><span class="token punctuation">(</span><span class="token string">'ccy'</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
		obj<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p><img src="https://s1.ax1x.com/2020/10/29/BJZYUs.png" alt></p> <p>可以看到，现在子类的原型上即没有了父类的构造器的属性，又将两个类的原型串联了起来，这样也可以使用 <code>instance</code> 操作符去判断。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.7b18d2f0.js" defer></script><script src="/assets/js/7.75a4d63f.js" defer></script>
  </body>
</html>
