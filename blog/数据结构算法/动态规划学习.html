<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>动态规划学习 | 车程一的博客</title>
    <meta name="description" content="车程一的博客">
    <link rel="icon" href="/vue-logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fbf6f8b.css" as="style"><link rel="preload" href="/assets/js/app.7b18d2f0.js" as="script"><link rel="preload" href="/assets/js/41.a5df0168.js" as="script"><link rel="prefetch" href="/assets/js/10.ea08bc69.js"><link rel="prefetch" href="/assets/js/11.59d62fd9.js"><link rel="prefetch" href="/assets/js/12.426af9d7.js"><link rel="prefetch" href="/assets/js/13.b2bd6144.js"><link rel="prefetch" href="/assets/js/14.1790ff5e.js"><link rel="prefetch" href="/assets/js/15.584f93ea.js"><link rel="prefetch" href="/assets/js/16.659d2a43.js"><link rel="prefetch" href="/assets/js/17.7825b058.js"><link rel="prefetch" href="/assets/js/18.0b08fef9.js"><link rel="prefetch" href="/assets/js/19.c553a9ae.js"><link rel="prefetch" href="/assets/js/2.ef1579f9.js"><link rel="prefetch" href="/assets/js/20.1a95086a.js"><link rel="prefetch" href="/assets/js/21.57c66887.js"><link rel="prefetch" href="/assets/js/22.3570ca0d.js"><link rel="prefetch" href="/assets/js/23.7fe8ebe9.js"><link rel="prefetch" href="/assets/js/24.5c706192.js"><link rel="prefetch" href="/assets/js/25.d8757158.js"><link rel="prefetch" href="/assets/js/26.8399a71b.js"><link rel="prefetch" href="/assets/js/27.4b3a213a.js"><link rel="prefetch" href="/assets/js/28.eb31cdf1.js"><link rel="prefetch" href="/assets/js/29.577144a6.js"><link rel="prefetch" href="/assets/js/3.62eea2c7.js"><link rel="prefetch" href="/assets/js/30.ef956d23.js"><link rel="prefetch" href="/assets/js/31.2e8ab40d.js"><link rel="prefetch" href="/assets/js/32.9d1685a0.js"><link rel="prefetch" href="/assets/js/33.d800be4d.js"><link rel="prefetch" href="/assets/js/34.85d350fe.js"><link rel="prefetch" href="/assets/js/35.1625e166.js"><link rel="prefetch" href="/assets/js/36.5cf7699d.js"><link rel="prefetch" href="/assets/js/37.0437fe8d.js"><link rel="prefetch" href="/assets/js/38.ca058290.js"><link rel="prefetch" href="/assets/js/39.d4f95e20.js"><link rel="prefetch" href="/assets/js/4.91c625b2.js"><link rel="prefetch" href="/assets/js/40.211acfac.js"><link rel="prefetch" href="/assets/js/42.6318b490.js"><link rel="prefetch" href="/assets/js/43.a6543bac.js"><link rel="prefetch" href="/assets/js/44.b04565e5.js"><link rel="prefetch" href="/assets/js/45.3bb1a5c1.js"><link rel="prefetch" href="/assets/js/46.15ed4362.js"><link rel="prefetch" href="/assets/js/47.e838dcd2.js"><link rel="prefetch" href="/assets/js/48.0a220d6c.js"><link rel="prefetch" href="/assets/js/49.a81b7774.js"><link rel="prefetch" href="/assets/js/5.a6bc510c.js"><link rel="prefetch" href="/assets/js/50.5ae2a1df.js"><link rel="prefetch" href="/assets/js/51.1e50c0a5.js"><link rel="prefetch" href="/assets/js/52.05832c5b.js"><link rel="prefetch" href="/assets/js/6.edf1ab01.js"><link rel="prefetch" href="/assets/js/7.75a4d63f.js"><link rel="prefetch" href="/assets/js/8.ac427bc7.js"><link rel="prefetch" href="/assets/js/9.7c5ccd0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fbf6f8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">车程一的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>前端实战</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>react理解</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>总结记录</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>数据结构算法</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/数据结构算法/归并排序.html" class="sidebar-link">归并排序</a></li><li><a href="/blog/数据结构算法/快速排序.html" class="sidebar-link">快速排序</a></li><li><a href="/blog/数据结构算法/插入排序和希尔排序.html" class="sidebar-link">插入排序和希尔排序</a></li><li><a href="/blog/数据结构算法/动态规划学习.html" class="active sidebar-link">动态规划学习</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_1-爬楼梯-斐波那切数列问题" class="sidebar-link">1 爬楼梯&amp;斐波那切数列问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_2-最大子序和问题" class="sidebar-link">2 最大子序和问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_3打家劫舍问题" class="sidebar-link">3打家劫舍问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_4区域和检索" class="sidebar-link">4区域和检索</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_5-粉刷房子问题" class="sidebar-link">5 粉刷房子问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_6-零钱兑换问题" class="sidebar-link">6 零钱兑换问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_7-最小路径和问题" class="sidebar-link">7 最小路径和问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_7-1-使用递归实现" class="sidebar-link">7.1 使用递归实现</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_7-2-使用动态规划的方式去考虑" class="sidebar-link">7.2 使用动态规划的方式去考虑</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_8-不同路径" class="sidebar-link">8 不同路径</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_9-最长公共子序列" class="sidebar-link">9 最长公共子序列</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_10-剪绳子问题" class="sidebar-link">10 剪绳子问题</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_11-最长不重复子串" class="sidebar-link">11 最长不重复子串</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_12-股票问题" class="sidebar-link">12 股票问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_12-1-含冷冻期" class="sidebar-link">12.1 含冷冻期</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_12-2-含手续费" class="sidebar-link">12.2 含手续费</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_13-博弈问题" class="sidebar-link">13 博弈问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_13-1-nim游戏" class="sidebar-link">13.1 Nim游戏</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_13-2-石子游戏" class="sidebar-link">13.2 石子游戏</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_13-3-石子游戏3" class="sidebar-link">13.3 石子游戏3</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_13-4-石子游戏5" class="sidebar-link">13.4 石子游戏5</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_14-分割回文字符串-ii" class="sidebar-link">14 分割回文字符串 II</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_15-扰乱字符串" class="sidebar-link">15 扰乱字符串</a></li><li class="sidebar-sub-header"><a href="/blog/数据结构算法/动态规划学习.html#_16-解码方法" class="sidebar-link">16 解码方法</a></li></ul></li><li><a href="/blog/数据结构算法/回溯算法学习.html" class="sidebar-link">回溯算法学习</a></li><li><a href="/blog/数据结构算法/最小堆.html" class="sidebar-link">最小堆</a></li><li><a href="/blog/数据结构算法/滑动窗口.html" class="sidebar-link">滑动窗口</a></li><li><a href="/blog/数据结构算法/字典树.html" class="sidebar-link">字典树</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="动态规划学习"><a href="#动态规划学习" aria-hidden="true" class="header-anchor">#</a> 动态规划学习</h1> <h2 id="_1-爬楼梯-斐波那切数列问题"><a href="#_1-爬楼梯-斐波那切数列问题" aria-hidden="true" class="header-anchor">#</a> 1 爬楼梯&amp;斐波那切数列问题</h2> <blockquote><p>问题：
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote> <table><thead><tr><th>台阶数</th> <th>跳法</th></tr></thead> <tbody><tr><td>1</td> <td>1</td></tr> <tr><td>2</td> <td>2</td></tr> <tr><td>3</td> <td>fn(3-1) + fn(3-2)</td></tr> <tr><td>4</td> <td>fn(4-1) + fn(4-2)</td></tr></tbody></table> <p>可以看到，题目描述的是，青蛙每次只能跳1级台阶或者2级台阶。设青蛙跳n级台阶的次数为：<code>fn(n)</code>，如果青蛙最后跳到最后一步只能1级台阶，那么说明之前有 <code>fn(n-1)</code> 种条法，如果跳到最后只剩2级台阶，说明之前有 <code>fn(n-2)</code> 种跳法。那么可以得出公式：<code>fn(n) = fn(n-1) + fn(n-2)</code>。</p> <p>由此这个跳台阶的问题就转化成了一个与斐波那切数列类似的问题，某一项等于前两项之和。所以很快可以写出此题的递归解法：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">getNums</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 需要注意0阶台阶也是一种跳法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span>
        <span class="token keyword">return</span> <span class="token function">getNums</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getNums</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>此题是leetcode 上的原题：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/</p> <p>当时的我写出这个答案发现在leecode上直接执行超时了。</p> <p>接下来看看动态规划的解法。</p> <ul><li>首先是状态定义，需要保存某个状态对应的值，我习惯的是用map。</li> <li>其次是转移方程，即：<code>dp[i+1]=dp[i]+dp[i-1]</code></li> <li>初使状态就是：<code>dp[0]=1; dp[1]=1</code></li> <li>最后返回的值就是 <code>dp[n]</code></li></ul> <p>代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> numWays <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// leetcode 上需要%上这个数字</span>
            <span class="token comment">// var num = (dp[i-1] + dp[i-2]) % 1000000007;</span>
            <span class="token keyword">var</span> num <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这里还有优化的空间，我们用 <code>dp</code> 保存了所有子问题对应的值，但是实际上我们每次计算用到的是前两项的值，那么我们只需要两个变量去保存前两项的值，然后在叠加的过程中去更新就行了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">numWays</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// return fn(n, {})</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> llnum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> lnum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// now = (llnum + lnum) % 1000000007;</span>
        now <span class="token operator">=</span> llnum <span class="token operator">+</span> lnum<span class="token punctuation">;</span>
        llnum <span class="token operator">=</span> lnum<span class="token punctuation">;</span>
        lnum <span class="token operator">=</span> now<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> now
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_2-最大子序和问题"><a href="#_2-最大子序和问题" aria-hidden="true" class="header-anchor">#</a> 2 最大子序和问题</h2> <blockquote><p>问题：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote> <p>示例：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
</code></pre></div><p>首先，思考，最大子序和，那就首先是算的连续数组的和，比如，例子数组中，第一项连续数组的和就是-2，第二项的话就是 <code>-2 + 1</code>，但是，第二项加上第一项的和反而小于它自身了，所以第算到二项最大和应该是它本身。也就是说，如果当前数组的前一项</p> <ul><li>首先是状态定义，设dp，dp[i] 表示以nums[i]元素结尾的连续子数组最大和</li> <li>其次是转移方程，如果dp[i-1]小于0，即会对dp[i]产生负的贡献，所以dp[i]等于nums[i]本身，得出：<div class="language-js extra-class"><pre class="language-js"><code>     <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
     <span class="token punctuation">}</span>
</code></pre></div></li> <li>初使状态就是：dp[0] = nums[0]</li> <li>返回值：返回dp中的最大值</li></ul> <p>写出代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> maxNum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个最大数用于存储</span>
        <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maxNum <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                maxNum <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>与之前爬楼梯的优化方法相似，实际上算dp[i]的时候，只用到了前一项的数据，所以没必要用dp把结果全都保存下来，用一个变量存储上一项的数据就行了。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> maxNum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 设置一个最大数用于存储</span>
        <span class="token keyword">var</span> n <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> n <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                n <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&gt;</span> maxNum <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                maxNum <span class="token operator">=</span> n
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span>
</code></pre></div><h2 id="_3打家劫舍问题"><a href="#_3打家劫舍问题" aria-hidden="true" class="header-anchor">#</a> 3打家劫舍问题</h2> <p>在leetcode上原题：https://leetcode-cn.com/problems/house-robber/</p> <blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p></blockquote> <p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p> <p>示例：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
      偷窃到的最高金额 = 1 + 3 = 4 。

</code></pre></div><p>试想，如果我们遇到的房子是：<code>[1,3,1]</code>,同样, 先用一个dp去记录局部问题的最优解，大问题分为小问题去解决，在遇到需要为0的第一间房子的时候，此时肯定：<code>dp[0]=nums[0]</code>，在到了第二件房子，由于不能偷连续的房子，肯定要偷当前价值比较大的那一间，所以 <code>dp[1] = Math.max(nums[1], dp[0])</code>，走到第三间房子的时候，有两个选择，1是选择偷第三间房间和第一间房间，或者不偷第三间房，保留当前的成果。这两个选择中肯定选择利益更大的那个选择。
所以得出公式：<code>dp[i] = Math.max(nums[i]+dp[i-2], dp[i-1])</code></p> <p>得出公式就可以写出代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">rob</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>num <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>

</code></pre></div><h2 id="_4区域和检索"><a href="#_4区域和检索" aria-hidden="true" class="header-anchor">#</a> 4区域和检索</h2> <p>leetcode原题：https://leetcode-cn.com/problems/range-sum-query-immutable/</p> <blockquote><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3

</code></pre></div><p>做这个题的话，其实直接计算的时候每次遍历数组计算就行了，怎么使用动态规划来解答这道题呢？
首先，它计算的是一个区域内的连续子数组的和，老四步：</p> <ul><li>首先是状态定义，设一个dp用于保存下标为i的时候，0到i的和。</li> <li>其次是转移方程，设想，如果是算第一项的和，那么结果肯定是dp[0], 如果是算第一项和第二项的和，那么结果就是 <code>dp[0]+nums[i]</code>，首先按照这个思想把从0到当前下标的和存到dp中，在思考，如果要计算从下标1到下标2的和，dp[2]指的是0,1,2的值，那只要减出下标0的，剩下的不就是1，2的了？</li> <li>初使状态就是：<code>dp[0] = nums[0]</code></li> <li>最后返回的值就是 <code>sum(i,j), i=0: dp[j], i!=0: dp[j]-dp[i-1]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">NumArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/** 
 * @param {number} i 
 * @param {number} j
 * @return {number}
 */</span>
NumArray<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sumRange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_5-粉刷房子问题"><a href="#_5-粉刷房子问题" aria-hidden="true" class="header-anchor">#</a> 5 粉刷房子问题</h2> <p>leetcode：https://leetcode-cn.com/problems/paint-house/</p> <blockquote><p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。
当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。
例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p></blockquote> <p>示例：</p> <div class="language- extra-class"><pre class="language-text"><code>输入: [[17,2,17],[16,16,5],[14,3,19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
     最少花费: 2 + 5 + 3 = 10。
</code></pre></div><p>对于第一间房子决定刷成什么颜色，直接决定了后续的房子颜色的粉刷路线，但是，刷第一件屋子的时候就叫我去考虑后面的房子的问题，这考虑起来未免也太头大了。反正能确定的 是，第一间屋子最终刷的颜色就是 红黄蓝三种颜色其中一种。
根据示例题目画出下面的图：
<img src="https://user-gold-cdn.xitu.io/2020/5/27/17251be50efc73ea?w=401&h=191&f=png&s=14011" alt></p> <p>我们从最后一间房子开始去考虑，此时刷三种颜色的价格已经在二位数组里面记录了，设二位数字为 <code>costs</code>，则分别是 <code>costs[2][0]</code> <code>costs[2][1]</code> <code>costs[2][2]</code>。然后再去考虑下标为1的房子，此时把选择每种颜色花的最少的钱记录下来，对于刷红色16，那下标为2的房子就只能选择蓝色或者绿色，取其中小的3，则刷红色最少需要19；如果下标为1的房子选择刷蓝色，那么下标为2的房子只能刷红色或者绿色，也去其中小的则最少需要25，同理，下标为1的房子刷绿色最少需要8. 那么如果只有两间房，最好就是刷绿色，最少就是需要8。 对于下标为0的第三间房子，在通过这种计算方式得到了选择每种颜色分别需要花费的价格，然后取出最小值就得到了答案。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">minCost</span><span class="token punctuation">(</span>costs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>costs<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>costs<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span>costs<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> n <span class="token operator">=</span> costs<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
            costs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            costs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
            costs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> costs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="_6-零钱兑换问题"><a href="#_6-零钱兑换问题" aria-hidden="true" class="header-anchor">#</a> 6 零钱兑换问题</h2> <p>leetcode：https://leetcode-cn.com/problems/coin-change/</p> <blockquote><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p></blockquote> <p>示例 1:</p> <div class="language- extra-class"><pre class="language-text"><code>输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
</code></pre></div><p>关键点：</p> <ol><li>当前金额是否有必要拆成更小子问题，比如 <code>amount=5</code> 可以拆解为 <code>2+2+1</code>，但是硬币面值已经有5了，所以没有必要。在比如硬币3，拆解为<code>fn(1),fn(2)</code>两个子问题，如果我们已经计算出了<code>fn(1),fn(2)</code>的最优解，那么<code>fn(3)</code>肯定也是最优解。就像考试，如果你想考最高分，你只需要保证每一门科目都考最高分，在化解成每个科目里的每种题类型都考最高分...如果一个结果依赖与其他两个结果相加，那么只要保证那两个结果是最优的，就能保证当前计算的这个结果是最优的。</li> <li>说到底，还是要求出一些金额的最优解，因为到了最后一步，还是要选择 [1,2,5] 其中的一个硬币，设一个dp用于保存相应的金额所需要的最少的硬币数。假如现在已经选到了最后一步，总的金额是11，如果我选择硬币1，那么当前所需要的次数就是 <code>dp[11-1] + 1</code>, 如果选择的是硬币2，则次数为：<code>dp[11-2] + 1</code>, 如果选择的是硬币5，则次数为: <code>dp[11-5] + 1</code>次，最后取这三个结果的最小值，即得到了凑出11所需要的最小硬币数。</li> <li>在是要考虑凑不出金额的情况，假设我们所需要的金额为 <code>amount</code>，实际上硬币的最小面值是1， 如果最后计算出的数字最少需要 <code>amount + 1</code> 次，则说明根本凑不出需要的金额。</li></ol> <p>推导：</p> <ul><li>首先是状态定义，需要保存没个金额对应的最小的硬币数，dp。</li> <li>其次是转移方程，即：<code>dp[i] = Math.min( dp[i], dp[i-coin]+1)</code>。其中coin是硬币的面值，</li> <li>初使状态就是：<code>dp[0] = 0, dp[i] = amount + 1</code>， 为什么要预设 <code>dp[i] = amount + 1</code>呢？因为上面的假设3，如果最后的 <code>dp[amount]==amount+1</code>，则说明凑不出需要的金额，返回 -1.</li> <li>最后返回的值就是 <code>dp[amount]==amount+1? -1 : dp[amount]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">function</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>amount<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>coins<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&gt;=</span> coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coins<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>与此题目类似的还有：<a href="https://leetcode-cn.com/problems/combination-sum-iv/" target="_blank" rel="noopener noreferrer">337.组合总和IV<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="_7-最小路径和问题"><a href="#_7-最小路径和问题" aria-hidden="true" class="header-anchor">#</a> 7 最小路径和问题</h2> <p>leetcode：https://leetcode-cn.com/problems/minimum-path-sum/
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p> <p>说明：每次只能向下或者向右移动一步。</p> <div class="language- extra-class"><pre class="language-text"><code>输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
</code></pre></div><h3 id="_7-1-使用递归实现"><a href="#_7-1-使用递归实现" aria-hidden="true" class="header-anchor">#</a> 7.1 使用递归实现</h3> <p>首先是使用递归去解决这个问题，开始的点和结束的点是固定的，第一步有两个选择走到3的地方或者走到1的地方，其实这里就相当于是一颗二叉树，每走到一步了我的下一步只有两个选择，然后使用递归的特质，从最后一步也就是最右下角的节点向上求解。
如图中所示2和1两个节点只有一种方式能走到下一步，
<img src="https://user-gold-cdn.xitu.io/2020/5/27/1725642610e63032?w=311&h=311&f=png&s=9542" alt>
所以得出在grid[2][1]位置走到终点的最小总和是3，grid[1][2]走到终点的最小总和是2，然后在思考grid[1][1]这个点走到终点的最小总和是多少，grid[1][1]只能走到grid[1][2]或者grid[2][1]，而这两个点走到终点的最小总和已经计算出来了，所以可以得出grid[1][1]走到终点的最小总和是 <code>grid[1][1] + grid[1][2]</code>，这样一步一步的网上推，最终可以得到第一步能走到的点 grid[0][1] 和 grid[1][0] 走到终点需要的最小总和，而这道题的解就是其中小的那一个加上起点的值。</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">var</span> <span class="token function-variable function">minPathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> x <span class="token operator">+</span> y
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">sum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> m<span class="token punctuation">,</span> n <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> m <span class="token operator">&gt;=</span> grid<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//说明已经到了最后一行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&gt;=</span> grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 进入这里说明已经是最后一个节点了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
            <span class="token keyword">return</span> grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> n <span class="token operator">&gt;=</span> grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token function">sum</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    <span class="token keyword">var</span> num <span class="token operator">=</span> grid<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// dp[m][n] = num</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> num
    <span class="token keyword">return</span> num
<span class="token punctuation">}</span>   
    <span class="token keyword">var</span> num <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token keyword">return</span> num <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在编码的过程中类似动态规划，使用一个二维数组dp来记录某个点走到终点的最小总和，这样每个点只用计算一次，可以有效的减少递归的层级。</p> <h3 id="_7-2-使用动态规划的方式去考虑"><a href="#_7-2-使用动态规划的方式去考虑" aria-hidden="true" class="header-anchor">#</a> 7.2 使用动态规划的方式去考虑</h3> <p>理解了之前的递归的写法，要写出动态规划就变得容易了很多</p> <p>推导：</p> <ul><li>首先是状态定义，对于二维数组中的某个点到终点的权值，dp[m][n] = x。</li> <li>其次是转移方程，即：`dp[m][n] = grid[m][n] + Math.min(dp[m-1][n], dp[m][n-1])</li> <li>初使状态就是：dp[row][line] = dp[row][line] 这里的row line代表二维数组的最后一个点的坐标。</li> <li>最后返回的值就是 dp[0][0]</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">minPathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>grid<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> row <span class="token operator">=</span> grid<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">var</span> line <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>

    <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span>row<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> j<span class="token operator">=</span>line<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">==</span> row <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> line <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">==</span> row <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> j <span class="token operator">==</span> line <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="_8-不同路径"><a href="#_8-不同路径" aria-hidden="true" class="header-anchor">#</a> 8 不同路径</h2> <p>leetcode: https://leetcode-cn.com/problems/unique-paths/
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p> <p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p> <p>问总共有多少条不同的路径？</p> <div class="language- extra-class"><pre class="language-text"><code>输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
</code></pre></div><p>首先这样的可以用二维数组的数据结构表示处这个网格。
推导：</p> <ul><li>首先是状态定义：dp,需要保存的二维数组中的某个点到终点也就是dp[m-1][n-1]有多少条路径。</li> <li>其次是转移方程：试想，每一次行动只能向右走一步或者向下走一步，所以可以得出公式：<code>dp[i][j] = dp[i+1][j] + dp[i][j+1]</code> 。</li> <li>初始状态：<code>dp[m-1][n-1]</code>是终点本身，所以 <code>dp[m-1][n-1]=1</code>，其次在设二维数组的时候要注意，因为对每一步求的是 i+1, j+1，有可能当前的i和j是最后一行和最后一列，为了在计算的时候方便， 所以设置的时候二维数组多一组行和列，值为0；</li> <li>最后返回的值就是 <code>dp[amount]==amount+1? -1 : dp[amount]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">uniquePaths</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    arr<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> row <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> j<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">==</span> m<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> n<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">continue</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">var</span> one <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
            <span class="token keyword">var</span> two <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> one <span class="token operator">+</span> two
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_9-最长公共子序列"><a href="#_9-最长公共子序列" aria-hidden="true" class="header-anchor">#</a> 9 最长公共子序列</h2> <p>leetcode: https://leetcode-cn.com/problems/longest-common-subsequence/</p> <p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p> <p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p> <p>若这两个字符串没有公共子序列，则返回 0。
示例：</p> <div class="language- extra-class"><pre class="language-text"><code>输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 
输出：3  
解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。
</code></pre></div><p>懒得画图了，用一张别人画好的图：
<img src="https://user-gold-cdn.xitu.io/2020/5/28/1725972aec4510b0?w=929&h=555&f=png&s=22779" alt>
比如现在有 <code>str1</code> 和 <code>str2</code>，一般情况下会创建一个二维数组dp用来保存 <code>str1</code>和 <code>str2</code> 的最长公共子传的各个子问题，比如，可以看到第一行和第一列时的最长公共字串都为1，这是因为在第一行时记录 <code>str1</code>是一个空字符串，在第一列时 <code>str2</code> 是一个空字符串。 在比如，dp[2][3]表示当前 str1 ac 和 str2 bab 的最长公共字串是1。</p> <p>接下来推导一波：</p> <ul><li>首先是状态定义，二维数组中dp[x][y]表示，当前str1从0到x处的字符串与 str2从0到y处的字符串的最长公共字串，需要注意，这里记录的字符串的第0为是从空开始的。</li> <li>其次是转移方程，这里会有两种情况，如果当前 <code>str1[x] == str2[y]</code> 则说明找到一个共同的字母了，最长公共子串的长度要加1了。或者没找到</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    if (str[x]==str[y]){
        dp[x][y] = dp[x-1]dp[y-1] + 1
    } else {
        dp[x][y] = Math.max(dp[x-1][y], dp[x][y-1])
    }
</code></pre></div><ul><li>初使状态就是：二维数组第一行和第一列的值都为0。</li> <li>最后返回的值就是：dp[x][y]</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">var</span> <span class="token function-variable function">longestCommonSubsequence</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>text1 <span class="token operator">||</span> <span class="token operator">!</span>text2 <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>text1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>text2<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> text1<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">var</span> prev <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> prev <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">var</span> a <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
                <span class="token keyword">var</span> b <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>text1<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">[</span>text2<span class="token punctuation">.</span>length<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_10-剪绳子问题"><a href="#_10-剪绳子问题" aria-hidden="true" class="header-anchor">#</a> 10 剪绳子问题</h2> <p>leetcode：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]<em>k[1]</em>...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p> <div class="language- extra-class"><pre class="language-text"><code>输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
</code></pre></div><p>分析：</p> <ul><li>状态定义：使用dp记录，某m米的绳子剪段自后最大的乘积</li> <li>初始状态：<code>dp[1]=1; dp[2]=1</code>,1m的绳子和2m的绳子，最长乘积只能是1</li> <li>转移方程：比如说一个8米的绳子，如果我们先考虑剪2m，下来，那么剩下6m。而2m和6m也能继续减，也能被化成更小的子问题。但是不是继续剪下去代表是最优的。比如2m，如果继续教程1*1m，那么乘积只有1，保持2m的话乘上其他数比剪成1m大。所以在这里是使用自身值还是使用dp里面保存的数字，我们应该取其中较大的值。设打算剪下的是j米(1&lt;=j&lt;i)，绳子长i米，得出转移方程：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>   var now = Math.max(j, dp[j]) * Math.max(i-j, dp[i-j])
   dp[i] = Math.max(now, dp[i])
</code></pre></div><p>代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">cuttingRope</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
   <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
   dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
   dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
       dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">var</span> now <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token operator">-</span>j<span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token punctuation">)</span>
           dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> now <span class="token punctuation">)</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_11-最长不重复子串"><a href="#_11-最长不重复子串" aria-hidden="true" class="header-anchor">#</a> 11 最长不重复子串</h2> <p>leetcode: https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</p> <p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p> <div class="language- extra-class"><pre class="language-text"><code>输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
</code></pre></div><p>分析：</p> <ul><li>状态定义，以dp[j] 保存字符串中以 s[j] 字符为结尾的最长不重复子串的长度。</li> <li>初始状态，<code>dp[0] = 1</code></li> <li>状态转移方程分析：</li></ul> <p>以示例中的字符串为例，比如我们此时正在计算 <code>j=3</code> 也就是 <code>a</code> 处的最长不重复字串应该如何去计算。按照动态规范的定义，很显然的可以想到是于 <code>dp[j-1]</code> 也就是 <code>dp[2]</code> 处的值有关的。但是，<code>dp[2]</code> 所包涵的最长不重复字串里，字符a已经出现过一次了。所以，在计算当前字符的最长不重复字串时，需要遍历之前的字符串看 当前字符串之前有没有出现过，如果出现了，是出现在哪个位置。 设遍历之前的字符串的index为 <code>i</code> ，<code>i</code>的初始值为<code>j-1</code>。</p> <p>会发生以下三种情况：</p> <ol><li><code>i&lt;0</code> 了，在之前的字符串中没有找到与 <code>s[j]</code> 相等的字符，那么此时<code>dp[j] = dp[j-1] + 1</code></li> <li>在之前的字符串中找到了与 <code>s[j]</code> 相等的字符， 但是 <code>dp[j-1] &lt; j-i</code> ，这是什么意思呢？意思就是 <code>dp[j-1]</code> 的最长不重复子串中并不包涵 <code>s[i]</code>，所以：还是可以得出：<code>dp[j] = dp[j-1] + 1</code></li> <li>第三中情况就是 <code>dp[j-1]&gt;=j-i</code>，说明 <code>dp[j-1]</code> 的最长不重复字串将 <code>s[i]</code> 包括了，此时 <code>dp[j] = j-i</code></li></ol> <p>状态转移方程已经分析完毕，最后在用一个变量记录过程中出现的最大值，最后返回这个最大值就可以了。最终代码为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">lengthOfLongestSubstring</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token comment">// 动态规划</span>
    <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">var</span> max <span class="token operator">=</span> <span class="token number">1</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> i <span class="token operator">=</span> j<span class="token operator">-</span><span class="token number">1</span>
        <span class="token keyword">var</span> str <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> str <span class="token operator">!==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
            i<span class="token operator">--</span>
            str <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> str <span class="token operator">==</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在区间外</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 区间内</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token operator">-</span>i
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> max<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span>
    <span class="token punctuation">}</span> 

    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>其实，对于遍历当前 索引j处 之前的字符看有没有出现过，可以用一个 hashMap 去替代：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">lengthOfLongestSubstring</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 动态规划 加 hash 表</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">var</span> dp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> 
    <span class="token keyword">var</span> indexDp <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 保存字母出现的最后一次索引</span>
    indexDp<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">var</span> max <span class="token operator">=</span> <span class="token number">1</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> indexDp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> undefined <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            indexDp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">var</span> lastIndex <span class="token operator">=</span> indexDp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>i<span class="token operator">-</span>lastIndex<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> lastIndex
            <span class="token punctuation">}</span>
            indexDp<span class="token punctuation">[</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
        <span class="token punctuation">}</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> max<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_12-股票问题"><a href="#_12-股票问题" aria-hidden="true" class="header-anchor">#</a> 12 股票问题</h2> <h3 id="_12-1-含冷冻期"><a href="#_12-1-含冷冻期" aria-hidden="true" class="header-anchor">#</a> 12.1 含冷冻期</h3> <p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​</p> <p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p> <p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:</p> <p>输入: [1,2,3,0,2]
输出: 3
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p> <p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> <p>股票问题的一系列问题是很经典的动态规划的题目。</p> <p>考虑这道题目，在每一天可以有哪几种状态？1.我可以选择持有一只股票（这里的持有不是指买入股票，因为可能持有的是前几天就买了的股票）；2.选择持有现金，卖出当前的股票，进入冷冻期。3.持有现金，不处于冷冻期，可以进行购买操作了。</p> <ul><li>状态定义：使用一个而为数组 dp 来记录状态，dp[i][0] 表示第i天持有一致股票的最大收益，dp[i][1]表示第i天卖出一只股票的最大收益，dp[i][2] 表示第i天处于冷冻期的最大收益。</li> <li>初始状态：初始状态为：[prices[0], 0, 0] 因为第一天，只能选择买入一只股票。</li> <li>状态转移方程：
<ol><li>首先考虑持有一只股票的情况，对于第i天持有了可以是前0～i天持有的股票，或者选择在当天购买一只股票，我们当前是选择其中代价最小的一个方案，如果我当天要购买一直股票，那么就要用前一天处于冷冻期时的收益减去当天这只股票的价格。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ol start="2"><li>第二种情况是我选择卖出股票。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li>第三种情况是当前持有的是现金， 处于冷冻期
dp[i][2] = Math.max( dp[i-1][1], dp[i-1][2] )</li></ol></li></ul> <p>注意：这里有一个点，就是转移方程中为什么 dp[i][2] = Math.max( dp[i-1][1], dp[i-1][2] )  是要取出前一天持有现金时，处于冷冻期和不处于冷冻期时的最大值。为什么不是：dp[i][2] = dp[i-1][1] ？ 这样仿佛看起来更是合理。因为前一天卖出了股票，所以今天处于冷冻期不能做任何操作，所以今天的收益等于昨天卖出股票的收益。</p> <p>我当时也信心满满的点了提交，然后遇到了一组测试用例子：[4,2,1]。 预期结果是0，算出的结果是-1。 什么原因呢，看这个数组，递减排列，只要选择买入了股票，最后一定是亏。所以在这组测试用例里面，我们最好的选择就是不买股票，持有现金。  而，dp[i][2] = dp[i-1][1] 这种状态就限制从始至终一定要至少买入一只股票。所以得出了错误的答案。</p> <p>更细节一点的分析，dp[i][1] 这个状态是怎么来的？ 它等于 <code>Math.max(dp[i-1][0] + prices[i])</code>，它依赖了 dp[i-1][0] 也就是持有一只股票的状态， 如果 <code>dp[i][2] = dp[i-1][1]</code> 那就表明至少买入一只股票了。 所以:
<code>dp[i][2] = Math.max( dp[i-1][1], dp[i-1][2] )</code> 为什么加入一个 dp[i-1][2] 判断就可以了呢？ 因为在初始化状态的时候，dp[0][2] 定义的就是0。</p> <p>所以本道题最后的答案，就是 <code>Math.max(dp[length-1][1], dp[length-1][2])</code>
为什么不考虑下标为0呢？因为最后肯定是持有现金的收益高，在持有现金的两种状态中取最优的。  而  dp[length-1][2]) 这个状态，其实也包含了从始至终没有买卖股票的状态</p> <h3 id="_12-2-含手续费"><a href="#_12-2-含手续费" aria-hidden="true" class="header-anchor">#</a> 12.2 含手续费</h3> <p>这里在看一道本道题的子母题，买卖股票最佳时机含手续费：</p> <p>题目链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</p> <p>手续费这道题就是每卖出一次股票需要 fee 手续费，没有冷冻期。我觉得这道题更能体现要考虑从始至终不买股票的状况。</p> <p>相比于前一题，对于每一天我可以选择 持有股票 和持有现金。</p> <ul><li>状态定义：使用二维数组 dp 记录在每一天选择持有股票和持有现金的最大收益。</li> <li>初始状态：<code>dp[0] = [-prices[i], 0]</code></li> <li>状态转移方程：
<ol><li>持有股票：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span>
</code></pre></div>2.持有现金：<div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee <span class="token punctuation">)</span>
</code></pre></div></li></ul> <p>需要注意的点还是在于对第i天选择持有现金的计算， 不能直接等于 <code>dp[i-1][0] + prices[i] - fee</code> ，因为 <code>dp[i-1][0]</code> 这个状态代表至少买了一只股票，而实际的情况可能会发生股票价格递减排列的情况，那时选择不买入股票才是最明智的选择。</p> <p>还有一点是，为什么要将手续费的计算放到卖出股票的时候呢？一笔交易只需要支付一次手续费，其实不管是放到买入股票的时候去计算还是卖出股票的时候去计算都是可以的，如果要放到买入股票的时候去计算。要注意初始状态定义的时候也要将手续费算进去：</p> <ul><li>状态定义：使用二维数组 dp 记录在每一天选择持有股票和持有现金的最大收益。</li> <li>初始状态：<code>dp[0] = [-prices[i]-fee, 0]</code></li> <li>状态转移方程：
<ol><li>持有股票：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> fee <span class="token punctuation">)</span>
</code></pre></div>2.持有现金：<div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span>
</code></pre></div></li></ul> <h2 id="_13-博弈问题"><a href="#_13-博弈问题" aria-hidden="true" class="header-anchor">#</a> 13 博弈问题</h2> <h3 id="_13-1-nim游戏"><a href="#_13-1-nim游戏" aria-hidden="true" class="header-anchor">#</a> 13.1 Nim游戏</h3> <p>你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p> <p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p> <p>示例:</p> <p>输入: 4
输出: false
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</p> <p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/nim-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> <p>其实做这种博弈类的问题，要抓住一个关键点，那就是，<em><strong>后手所面对的局面是由先手造成的</strong></em>。 比如有三堆石头，我可以一次就选择拿走3堆，那么就不剩下石头了，那后手就输了。</p> <ul><li>状态定义，使用数组 dp 记录，dp[n] 表示当有 n 块石头的时候，此时先手是胜还是负，胜为true，负为false</li> <li>初始状态： 毫无疑问, dp[1] dp[2] dp[3] 都为true</li> <li>状态定义：比如现在有n块石头，我选择拿到了其中的 1块， 那么后手所面临的局面就是 dp[n-1] 块， 此时dp[n-1]块的胜负情况就是后手的胜负情况，因为在dp[n-1]的时候，后手就是先手了，所以可以很容易的得到状态转移方程：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">!</span>dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span>dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token operator">!</span>dp<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token boolean">false</span>
</code></pre></div><p>最后这道题的题解就是 dp[n]</p> <p>然而，在leetcode提交了这段代码 会通过不了，原因是有一组测试数据n的值很大。 所以官方给出的这道题的答案是 <code>return (n % 4 != 0);</code>。 but anyway 这样动态规划解题的思路是正确的。</p> <h3 id="_13-2-石子游戏"><a href="#_13-2-石子游戏" aria-hidden="true" class="header-anchor">#</a> 13.2 石子游戏</h3> <p>亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。</p> <p>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。</p> <p>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。</p> <p>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。</p> <p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/stone-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> <h4 id="解法1"><a href="#解法1" aria-hidden="true" class="header-anchor">#</a> 解法1</h4> <p>得益与股票问题给予的思路，可以很快的想到，对于这道题也可以去记录对于石子堆每次先手能够拿到的最大数目和后手能够拿到的最大数目。</p> <ul><li><p>状态定义，使用二维数组 dp记录， dp[j][i] 表示从下标为 j 到 下标为 i 的石头堆先后手拿石头的情况，<code>.fir</code> 表示先手能拿到的手头，<code>.sec</code> 表示后手能拿到的石头。</p></li> <li><p>初始状态：假如只有一堆石头，也就是 <code>j==i</code> 的情况下:</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        fir<span class="token punctuation">:</span> piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>
        sec<span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>状态转移方程：对于从下标 j 到 i 的石头堆，我可以选择拿开头的石头堆<code>plies[j]</code> 也可以选择拿末尾的石头堆 <code>plies[i]</code>， 比如我拿的是 <code>plies[j]</code>，那么在 下标<code>j+1</code>到下标<code>i</code> 的石头堆中，我就处于后手了，所以此时我手中的石子数应该是：<code>plies[j] + dp[j+1][i].sec</code>。 对于此时后手的情况，在 下标<code>j+1</code>到下标<code>i</code> 的石头堆中 就要处于先手了,所以：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fir <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> plies<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> plies<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>
    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sec <span class="token operator">=</span> 上面所选择的状态的 fir
</code></pre></div><p>最后返回的结果就是：dp[0][piles.length-1].fir - dp[0][piles.length-1].sec &gt; 0</p> <h4 id="解法2"><a href="#解法2" aria-hidden="true" class="header-anchor">#</a> 解法2:</h4> <p>在 <code>leetcode</code> 的题解中发现有人说到了 “零和博弈” 这个词语。 我也不知道为什么要叫一个看起来不是很懂的词语，大概意思就是 在这种类型的问题中，最终两个人所拿到的分数相加起来就是 总的分数。</p> <p>还是要跟之前一样，使用一个二维数组dp来记录，dp[j][i] 表示从下标为 j 到 下标为 i 先手拿石头的情况。</p> <p>比如一个数组 <code>arr</code>，它的总和是 <code>num</code>， 如果我选择了从开头去拿一堆石头，那么此时后手能拿到的石头的情况就是 <code>dp[j+1][i]</code>， 因为两个人拿的数目加起来应该是要等于 总的石头数的。 所以 此时我那拿到的石头数目就应该是 <code>sum - dp[j+1][i]</code>。 所以很容易可以写出状态转移方程：</p> <div class="language-js extra-class"><pre class="language-js"><code>    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">sum</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>最后返回的结果为：<code>return dp[0][piles.length-1] * 2 &gt;= sum</code></p> <p>贴一下这个解法的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>piles<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        sum <span class="token operator">+=</span> piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// dp[j][i] = Math.max( piles[j]-dp[j+1][i], piles[i]-dp[j][i-1] )</span>
                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span> sum<span class="token operator">-</span>dp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> sum<span class="token operator">-</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>piles<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&gt;=</span> sum
</code></pre></div><h3 id="_13-3-石子游戏3"><a href="#_13-3-石子游戏3" aria-hidden="true" class="header-anchor">#</a> 13.3 石子游戏3</h3> <p>Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。</p> <p>Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。</p> <p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p> <p>假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 &quot;Alice&quot; ，Bob 赢了就返回 &quot;Bob&quot;，平局（分数相同）返回 &quot;Tie&quot; 。</p> <p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/stone-game-iii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> <h3 id="_13-4-石子游戏5"><a href="#_13-4-石子游戏5" aria-hidden="true" class="header-anchor">#</a> 13.4 石子游戏5</h3> <p>几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。</p> <p>游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。</p> <p>只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。</p> <p>返回 Alice 能够获得的最大分数 。</p> <p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/stone-game-v
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p> <p>在leetcode写过题解，这里偷个懒不写了，直接链接：https://leetcode-cn.com/problems/stone-game-v/solution/javascript-dong-tai-gui-hua-si-lu-qing-xi-by-chech/</p> <h2 id="_14-分割回文字符串-ii"><a href="#_14-分割回文字符串-ii" aria-hidden="true" class="header-anchor">#</a> 14 分割回文字符串 II</h2> <div class="language- extra-class"><pre class="language-text"><code>示例 1：

输入：s = &quot;aab&quot;
输出：1
解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。
示例 2：

输入：s = &quot;a&quot;
输出：0
示例 3：

输入：s = &quot;ab&quot;
输出：1

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/palindrome-partitioning-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre></div><p>这道题，首先要考虑解决的一个问题就是，在可以尝试随意的切割字符串的情况下，如何判断一个字符串是否为回文字符串。很简单的可以想到使用双指针的方式去判断是否回文字符串。但是在本题中，很有可能出现需要多次判断的情况。所以我们考虑首先存储一下是否回文字符串的情况。使用一个二维数组 <code>dp</code>, <code>dp[i][j]</code> 表示从下标 <code>i</code> 到 <code>j</code> 的字符串是否为一个回文字符串。接下来我们来考虑一下推导方程。</p> <p><code>i</code> 和 <code>j</code> 有以下关系需要考虑：</p> <ul><li>1、<code>i===j</code>:
当 <code>i===j</code> 的时候，其实就是一个字符。那么 <code>dp[i][j]=true</code></li> <li>2 <code>i+1===j</code>:
这种情况下，字符串只有两个字符，所以只需要 <code>s[i]===s[j]</code> 则 <code>dp[i][j]=true</code></li> <li>3 <code>i+1 &gt; j</code>:
这种情况下，说明<code>s[i]</code> 和 <code>s[j]</code> 之间是有子串的。这时候只需要满足：<code>s[i]===s[j]</code> 且它们之间的子串也是回文字符串，则从下标 i 到 j 就是一个回文字符串。</li></ul> <p>做了这步操作之后，我们就可以使用 <code>O(1)</code> 的时间复杂度去查询 下标 i 到 j 的字符串是否是一个回文字符串了。</p> <p>然后在去考虑对一个字符串最少分割几次能切出都是回文字符串的问题。</p> <p>创建一个一维数组 <code>dp1</code>，<code>dp1[i]</code>表示从下标 0 到下标 i 的最少切割次数，最终我们需要的答案就是 <code>dp[0][s.length-1]</code>。如何去做这个动态规划的推到呢？比如我们现在的字符串是下标 i 到 j, 现在找出切割出的最后一个回文字符串，比如现在从下标 k 到下标 j 是一个回文字符串，那么 <code>dp1[k][j] = dp1[0][k-1] + 1</code>，还是熟悉的配方，将父问题切割成子问题，使用子问题的已知状态推倒出父问题。接下来上次题的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">minCut</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 一个二维数组 dp[i][j] 表示从下标i到下标j是否为一个回文字符串</span>
  <span class="token keyword">let</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span>length
  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span> i<span class="token operator">==</span>j <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">==</span>j <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> dp1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 一维数组，dp1[i] 表示从 0 到 i 的最少分割次数</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">Infinity</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果本身就是一个回文字符串则不需要切割</span>
      dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 多次判断，选取最小值  </span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span> dp1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> dp1<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>与该题类似的题还有：</p> <ul><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener noreferrer">5.最长回文字符串<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener noreferrer">516.最长回文子序列<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="_15-扰乱字符串"><a href="#_15-扰乱字符串" aria-hidden="true" class="header-anchor">#</a> 15 扰乱字符串</h2> <div class="language- extra-class"><pre class="language-text"><code>使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 &gt; 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/scramble-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
</code></pre></div><p>根据题目意义, 给定两个字符串 S 和 T， 我们可以假设 T 是根据 S变换而来。</p> <ul><li><p>如果 T 和 S 长度不一样，则不可能变换得到</p></li> <li><p>如果长度一样，S字符串和切割为 S1 和 S2， T 字符串也可以切割为 T1 和 T2。 那么现在可以对应得到两种情况：</p> <ol><li>顺序没有变换，S1 可以 变化得到 T1， S2 可以变换得到 T2</li> <li>顺序变换了，S1 可以变化得到 T2， S2 可以变换得到 T1</li></ol></li> <li><p>动态规划的最重要一点就是将大问题分解为子问题，经过刚刚的一步，我们将大问题分解为了验证刚刚所说的 1，2两点。
而 S1 、S2 等字符串也是可以继续去切割，所以我们可以通过确定的子问题去推导得出全局的解。</p></li> <li><p><strong>定义状态:</strong>
首先，要做的是定义出状态，使用一个三维数组 dp 去定义状态， <code>dp[i][j][len]</code> 表示的是：字符串 S 中从下标 i 开始长度为 len 的字符串是否能够通过变换得到 字符串 T 中从下标 j 开始长度为 len 的字符串。</p></li> <li><p><strong>状态转移方程</strong>
因为通过题意得知，我们是可以从任意位置去将字符串切割为两部分的，假设，切割的位置相对于当前字符串的长度len 为 k，则 字符串S 被切割成了 (i, k), (i+k, len-k) 两部分。此时有两种情况：</p> <ol><li>S1 =&gt; T1, S2 =&gt; T2 ，则此时的转移方程为：<code>dp[i][j][len] = dp[i][j][k] &amp;&amp; dp[i+k][j+k][len-k]</code></li> <li>S1 =&gt; T2, S2 =&gt; T1，则此时的转移方程为：<code>dp[i][j][len] = dp[i][j+len-k] &amp;&amp; dp[i+k][j][len-k]</code>。
(当 S1 =&gt; T2，T字符串必不可能从同样的地方进行切割，此时如果 S 切割的位置是 k，则 T 切割的位置为：j+len-k)</li></ol></li> <li><p><strong>初始状态</strong>
对于长度只有 1 的字符串，只有 S[i] === T[j] 才能变换。</p></li></ul> <p>接下来补充代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isScramble</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>s1<span class="token punctuation">.</span>length <span class="token operator">!==</span> s2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token keyword">let</span> n <span class="token operator">=</span> s1<span class="token punctuation">.</span>length
        <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
            <span class="token comment">// 初始化长度为1的时候的变量</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> s2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 枚举区间长度，因为长度为1的已经算出来了，所以这里从2开始，范围：2～n</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> len<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> len<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 枚举 S 字符串中的起点位置，区间 0 ~ n-len, 因为此时枚举的长度是 len， 所以起点的位置最多只能到 n-len</span>
          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// T 字符串中起点的位置，区间 0 ～ n-len</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// 枚举切割的位置 区间 1 ~ len-1 题目要求需要切割为两个非空的字符串</span>
              <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// S1 =&gt; T1  S2 =&gt; T2</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
                  <span class="token keyword">break</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// S1 =&gt; T2 S2 =&gt; T1</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span>len<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token operator">-</span>k<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>
                  <span class="token keyword">break</span>
                <span class="token punctuation">}</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_16-解码方法"><a href="#_16-解码方法" aria-hidden="true" class="header-anchor">#</a> 16 解码方法</h2> <div class="language- extra-class"><pre class="language-text"><code>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&quot;11106&quot; 可以映射为：

&quot;AAJF&quot; ，将消息分组为 (1 1 10 6)
&quot;KJF&quot; ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 &quot;06&quot; 不能映射为 &quot;F&quot; ，这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

示例 1：

输入：s = &quot;12&quot;
输出：2
解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。
</code></pre></div><p>使用动态规划的方法去解出这道题目的话，首先要定义出状态：</p> <ul><li><strong>状态定义：</strong> 使用一维数组 <code>dp</code> 记录状态，<code>dp[i]</code> 表示从字符串 s 中从下标 0 到下标 i 处解码的总数量。</li> <li><strong>初始状态：</strong> 初始状态 <code>dp[0] = 1</code>，这里需要注意的是，如果 <code>s[0] == '0'</code> 的话，代表整个字符串不可能解析成功，所以根本没有解析下去的必要了。所以代码一开始就要判断 <code>s[0]</code> 是否为 <code>'0'</code></li> <li><strong>状态转移方程：</strong> 其实这里和爬楼梯有一些类似，我们可以选择最后 1 位数字或者最后 2 位数组去解析成字符串。所以我们选取 <code>s[i]</code> 生成 <code>char</code>, <code>s[i-1] + s[i]</code> 生成 <code>dChar</code> <ol><li>由于 <code>&quot;0&quot;</code> 是不能解码的，且类似 <code>&quot;06&quot;</code> 也不能解码 为 <code>&quot;F&quot;</code>、<code>&quot;30&quot;</code> 不能解码，所以需要先确定生成的两个数字是否有对应的解码，如果都不能解码，那么代表这个字符串不能解码。判断条件：<code>char=='0' &amp;&amp; ( dChar &lt; 10 || dChar &gt; 26 )</code> 这样的情况下字符串不能解码</li> <li>如果 <code>char == '0'</code>，那么这里就只能使用 <code>dChar</code> 去解码，这样的情况下 <code>dp[i] = dp[i-2]</code>；</li> <li>如果 <code>dChar &gt;= 10 &amp;&amp; dChar &lt;= 26 &amp;&amp; char !== '0'</code>，说明这里可以仅使用 <code>char</code> 去解码，也能使用 <code>dChar</code> 去解码，得：<code>dp[i] = dp[i-1] + (dp[i-2] || 1)</code></li> <li>如果 <code>char</code> 不为 <code>&quot;0&quot;</code>, 但是 <code>dChar</code> 又不能解码，那么：<code>dp[i] = dp[i-1]</code></li></ol></li> <li><strong>结果：</strong> 最后我们需要的答案就是：<code>dp[s.length-1]</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">numDecodings</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> char <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">let</span> dChar <span class="token operator">=</span>  s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> char<span class="token operator">==</span><span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> dChar <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">||</span> dChar <span class="token operator">&gt;</span> <span class="token number">26</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span> char <span class="token operator">==</span> <span class="token string">'0'</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">1</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> dChar <span class="token operator">&gt;=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> dChar <span class="token operator">&lt;=</span> <span class="token number">26</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>dp<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>与这题比较类似的还有：<a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 46. 把数字翻译成字符串<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.7b18d2f0.js" defer></script><script src="/assets/js/41.a5df0168.js" defer></script>
  </body>
</html>
