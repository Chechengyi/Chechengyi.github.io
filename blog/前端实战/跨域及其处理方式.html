<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>跨域及其处理方式 | 车程一的博客</title>
    <meta name="description" content="车程一的博客">
    <link rel="icon" href="/vue-logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fbf6f8b.css" as="style"><link rel="preload" href="/assets/js/app.7b18d2f0.js" as="script"><link rel="preload" href="/assets/js/27.4b3a213a.js" as="script"><link rel="prefetch" href="/assets/js/10.ea08bc69.js"><link rel="prefetch" href="/assets/js/11.59d62fd9.js"><link rel="prefetch" href="/assets/js/12.426af9d7.js"><link rel="prefetch" href="/assets/js/13.b2bd6144.js"><link rel="prefetch" href="/assets/js/14.1790ff5e.js"><link rel="prefetch" href="/assets/js/15.584f93ea.js"><link rel="prefetch" href="/assets/js/16.659d2a43.js"><link rel="prefetch" href="/assets/js/17.7825b058.js"><link rel="prefetch" href="/assets/js/18.0b08fef9.js"><link rel="prefetch" href="/assets/js/19.c553a9ae.js"><link rel="prefetch" href="/assets/js/2.ef1579f9.js"><link rel="prefetch" href="/assets/js/20.1a95086a.js"><link rel="prefetch" href="/assets/js/21.57c66887.js"><link rel="prefetch" href="/assets/js/22.3570ca0d.js"><link rel="prefetch" href="/assets/js/23.7fe8ebe9.js"><link rel="prefetch" href="/assets/js/24.5c706192.js"><link rel="prefetch" href="/assets/js/25.d8757158.js"><link rel="prefetch" href="/assets/js/26.8399a71b.js"><link rel="prefetch" href="/assets/js/28.eb31cdf1.js"><link rel="prefetch" href="/assets/js/29.577144a6.js"><link rel="prefetch" href="/assets/js/3.62eea2c7.js"><link rel="prefetch" href="/assets/js/30.ef956d23.js"><link rel="prefetch" href="/assets/js/31.2e8ab40d.js"><link rel="prefetch" href="/assets/js/32.9d1685a0.js"><link rel="prefetch" href="/assets/js/33.d800be4d.js"><link rel="prefetch" href="/assets/js/34.85d350fe.js"><link rel="prefetch" href="/assets/js/35.1625e166.js"><link rel="prefetch" href="/assets/js/36.5cf7699d.js"><link rel="prefetch" href="/assets/js/37.0437fe8d.js"><link rel="prefetch" href="/assets/js/38.ca058290.js"><link rel="prefetch" href="/assets/js/39.d4f95e20.js"><link rel="prefetch" href="/assets/js/4.91c625b2.js"><link rel="prefetch" href="/assets/js/40.211acfac.js"><link rel="prefetch" href="/assets/js/41.a5df0168.js"><link rel="prefetch" href="/assets/js/42.6318b490.js"><link rel="prefetch" href="/assets/js/43.a6543bac.js"><link rel="prefetch" href="/assets/js/44.b04565e5.js"><link rel="prefetch" href="/assets/js/45.3bb1a5c1.js"><link rel="prefetch" href="/assets/js/46.15ed4362.js"><link rel="prefetch" href="/assets/js/47.e838dcd2.js"><link rel="prefetch" href="/assets/js/48.0a220d6c.js"><link rel="prefetch" href="/assets/js/49.a81b7774.js"><link rel="prefetch" href="/assets/js/5.a6bc510c.js"><link rel="prefetch" href="/assets/js/50.5ae2a1df.js"><link rel="prefetch" href="/assets/js/51.1e50c0a5.js"><link rel="prefetch" href="/assets/js/52.05832c5b.js"><link rel="prefetch" href="/assets/js/6.edf1ab01.js"><link rel="prefetch" href="/assets/js/7.75a4d63f.js"><link rel="prefetch" href="/assets/js/8.ac427bc7.js"><link rel="prefetch" href="/assets/js/9.7c5ccd0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fbf6f8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">车程一的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>前端实战</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/前端实战/跨域及其处理方式.html" class="active sidebar-link">跨域及其处理方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#什么是跨域及浏览器同源策略" class="sidebar-link">什么是跨域及浏览器同源策略</a></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#解决-xmlhttprequest-的跨域" class="sidebar-link">解决 XMLHttpRequest 的跨域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#jsonp" class="sidebar-link">JSONP</a></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#cors" class="sidebar-link">CORS</a></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#代理" class="sidebar-link">代理</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#cookie-的跨域" class="sidebar-link">cookie 的跨域</a></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#跨窗口的通信" class="sidebar-link">跨窗口的通信</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#使用hash" class="sidebar-link">使用hash</a></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#使用window-name" class="sidebar-link">使用window.name</a></li><li class="sidebar-sub-header"><a href="/blog/前端实战/跨域及其处理方式.html#window-postmessage" class="sidebar-link">window.postMessage</a></li></ul></li></ul></li><li><a href="/blog/前端实战/移动端适配问题.html" class="sidebar-link">移动端适配问题</a></li><li><a href="/blog/前端实战/给localStorage加上过期时间.html" class="sidebar-link">给localStorage加上过期时间</a></li><li><a href="/blog/前端实战/react实现一个分页、搜索高阶组件.html" class="sidebar-link">react实现一个分页、搜索高阶组件</a></li><li><a href="/blog/前端实战/nginx设置资源缓存实战.html" class="sidebar-link">nginx设置资源缓存实战</a></li><li><a href="/blog/前端实战/前后端分离下前端权限处理.html" class="sidebar-link">前后端分离下前端权限处理</a></li><li><a href="/blog/前端实战/从react hooks“闭包陷阱”切入，浅谈react hooks.html" class="sidebar-link">从react hooks“闭包陷阱”切入，浅谈react hooks</a></li><li><a href="/blog/前端实战/BFC及其理解.html" class="sidebar-link">BFC及其理解</a></li><li><a href="/blog/前端实战/react优化-精确更新视窗内组件.html" class="sidebar-link">react优化-精确更新视窗内组件</a></li><li><a href="/blog/前端实战/typescript内置类型学习.html" class="sidebar-link">typescript内置类型学习</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>react理解</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>总结记录</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构算法</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="跨域及其处理方式"><a href="#跨域及其处理方式" aria-hidden="true" class="header-anchor">#</a> 跨域及其处理方式</h1> <h2 id="什么是跨域及浏览器同源策略"><a href="#什么是跨域及浏览器同源策略" aria-hidden="true" class="header-anchor">#</a> 什么是跨域及浏览器同源策略</h2> <p><img src="https://ae01.alicdn.com/kf/Hbf31fc793eeb4897a66d9900d9b48bbb3.jpg" alt>
这是我在本地模拟的，一个位于 <code>8081</code> 端口下的html文件里使用异步请求 GET 去访问 8082 端口下的一个接口，然后报出了这样的错误。</p> <p>跨域这个名字是由于浏览器同源策略产生的，浏览器同源策略是浏览器为了安全而产生的一种约定。什么是同源呢，就是同协议、同域名、同端口。</p> <p>下面举例子看对于 <strong>http://www.baidu.com/index.html</strong> 会不会造成跨域：</p> <table><thead><tr><th>URL</th> <th>结果</th> <th>原因</th></tr></thead> <tbody><tr><td>http://www.baidu.com/blog/index.html</td> <td>成功</td> <td>协议、域名、端口均相同，路径不同而已</td></tr> <tr><td>https://www.baidu.com/index.html</td> <td>失败</td> <td>协议不同</td></tr> <tr><td>http://mm.baidu.com/index.html</td> <td>失败</td> <td>域名不同（二级域名不同）</td></tr> <tr><td>http://www.baidu.com:8080/index.html</td> <td>失败</td> <td>端口不同</td></tr></tbody></table> <p>如果网页之间不满足 同源 要求， 将不能：</p> <ol><li>读取 cookie 、localStorage 、sessionStorage 等资源。
举例，在 <code>www.taobao.com</code> 下肯定读取不到 <code>www.baidu.com</code> 的以上资源。因为这些都是根据域名去存储的</li> <li>发送 XHR 异步请求。这没什么好说的，注意是XHR异步请求，就是 <code>XMLHttpRequest</code> 对象，表单是可以跨域 提交的，不仅如此，还会自动带上当前请求的那个域名的 <code>cookie</code>，这就是 <code>corf</code> 跨站请求伪造的由来</li> <li>获取DOM。</li></ol> <p>但是也有一些是不受同源限制的，比如：</p> <ol><li>页面中的链接，重定向以及表单提交不会受到同源策略限制。</li> <li>跨域的资源是可以互相引入的，如嵌入到页面中的 <code>&lt;script&gt;、&lt;img&gt;</code>，等等。</li></ol> <h2 id="解决-xmlhttprequest-的跨域"><a href="#解决-xmlhttprequest-的跨域" aria-hidden="true" class="header-anchor">#</a> 解决 XMLHttpRequest 的跨域</h2> <h3 id="jsonp"><a href="#jsonp" aria-hidden="true" class="header-anchor">#</a> JSONP</h3> <p><strong>JSONP</strong> 就是利用了 <code>&lt;script&gt;</code> 标签不受同源策略的影响来实现跨域的。但是只能用于 <code>GET</code> 请求，具体的实现方式是，在网页中创建一个 <code>&lt;script&gt;</code> 标签，请求的地址为目标url。请求的查询字符串有一个 <code>callback</code> 参数，用来指定回调函数的名称，回调函数在js中事先声明好。让服务器接收到请求后，返回js脚本，内容是将json数据作为参数传入回调函数并且执行该函数。</p> <h3 id="cors"><a href="#cors" aria-hidden="true" class="header-anchor">#</a> CORS</h3> <p>CORS 是跨域资源分享的缩写，通过设置服务端的响应头解决 XMLHttpRequest 跨域的问题，这样就可以允许任意类型的请求，需要服务器设置以下响应头：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//*表示允许任意源的访问，也可以指定特定的源</span>
<span class="token number">1.</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin：<span class="token operator">*</span>   
<span class="token comment">//表示跨域访问时带上cookie，需同时在ajax请求中设置`withCredentials: true`，</span>
<span class="token number">2.</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token comment">//预检请求后响应的必须字段，返回所有支持的方法，而不单是浏览器请求的那个方</span>
<span class="token comment">//法。这是为了避免多次&quot;预检&quot;请求</span>
<span class="token number">3.</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token punctuation">:</span> <span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">PUT</span>
<span class="token comment">//预检请求后响应的必须字段，放入预检请求时请求所带的头</span>
<span class="token number">4.</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers：Content<span class="token operator">-</span>Type
<span class="token comment">//允许浏览器在指定时间内，无需再发送预检请求进行协商，直接用本次协商结果即可</span>
<span class="token number">5.</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token punctuation">:</span> <span class="token number">1728000</span>
</code></pre></div><p>CORS请求分为简单请求<code>(HEAD、GET、POST)</code>和非简单请求<code>(PUT或DELETE或Content-Type为application)</code> 非简单请求会向发一个预检请求(preflight)，请求类型为OPTION，收到预检请求的响应后再发送真正的请求，这个时候的请求与简单请求无异。也就是说，对于简单请求，其实已经发送到服务器上并且服务器也会执行相应的逻辑，只是浏览器拦截了响应，提示用户已经跨域了。而对于非简单请求，浏览器会先发送一个 预检请求(preflight)，请求类型为 <code>OPTION</code> 收到预检请求的响应验证无误后再发送真正的请求，如果验证不通过，则非简单请求不在向浏览器发起。</p> <p>预检查会携带的信息为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 必要请求头，表示当前源，相应的预检响应需要返回Access-Control-Allow-Origin</span>
<span class="token number">1.</span>Origin
<span class="token comment">//预检时会带上的头，表示真正请求的方法，相应的预检响应需要返回Access-Control-Allow-Method</span>
<span class="token number">2.</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Method
<span class="token comment">//预检时会带上的头，表示真正请求会额外发送的头信息，相应的预检响应需要返回</span>
</code></pre></div><p>同样的，服务端对于预检请求会返回相应信息。
<img src="https://s1.ax1x.com/2020/06/02/tNIFgA.png" alt></p> <p>比如图中的这个预检请求的信息就可以看出，原本的请求是一个 <code>PUT</code> 请求来源是 <code>localhost:3003</code>， 服务端响应了这个请求可以发现服务端的设置 <code>Access-Control-Allow-Origin</code> 为 <code>*</code>， 但是没有看到 <code>Access-Control-Allow-Methods</code> 设置允许 <code>PUT</code> 的信息，所以这个请求会提示跨域。复杂请求需要在 <code>Access-Control-Allow-Methods</code> 里面设置相应方法允许才可以。</p> <h3 id="代理"><a href="#代理" aria-hidden="true" class="header-anchor">#</a> 代理</h3> <p>同源策略是针对于浏览器端的，不针对于服务器。所以可以使用中间服务器做代理，将请求转发到目标服务器上，然后目标服务器响应中间服务器后中间服务器在响应浏览器。 现在我在项目中使用到的代理有两种：</p> <p>一是在开发环境下本地起了一个服务的情况下去访问后台服务肯定是会跨域的。这时配置 proxy 去解决这个问题。 二是在生产环境下前端资源打包成了一堆静态的资源，然后部署到 nginx 服务器上，在由 <code>nginx</code> 服务器去做代理。</p> <h2 id="cookie-的跨域"><a href="#cookie-的跨域" aria-hidden="true" class="header-anchor">#</a> cookie 的跨域</h2> <p>首先看看 <code>cookie</code> 有哪些属性：</p> <table><thead><tr><th>属性</th> <th>含义</th></tr></thead> <tbody><tr><td>expires</td> <td>过期时间</td></tr> <tr><td>domain 和 path</td> <td>限定了cookie能被那些URL访问</td></tr> <tr><td>secure</td> <td>设置cookie只在确保安全的请求中才会发送，比如https</td></tr> <tr><td>httpOnly</td> <td>设置cookie是否能通过 js 去访问</td></tr> <tr><td>SameSite</td> <td>用来限制第三方cookie，有三个值，Strict、Lax、None</td></tr></tbody></table> <blockquote><p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie;<code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外;Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p></blockquote> <p><img src="https://s3.ax1x.com/2021/03/12/6ULAlF.png" alt></p> <p>(图片来自：https://zhuanlan.zhihu.com/p/114093227)</p> <p>关于SameSite的详细信息，可以看阮一峰的博客：<a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener noreferrer">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>cookie</code> 的跨域可以通过设置 <code>document.domain</code> 来解决。前提条件是两个域名必须属于同一个基础域名。否则设置 <code>document.domain</code> 也是无效的，这也是出于安全考虑。比如：<code>www.baidu.com</code> 和 <code>mm.baidu.com</code>。可以通过设置 <code>document.domain=.baidu.com</code>。来实现跨域访问 <code>cookie</code> 的目的。 比如要实现 <code>a.xxx.com</code> 和 <code>b.xxx.com</code> 之间的<code>cookie</code>共享。就可以把这两个页面都设置 <code>document.domain=xxx.com</code>。这样在 <code>a.xxx.com</code> 下建立的 <code>cookie</code> 可以在 <code>b.xxx.com</code> 下访问到，在 <code>b.xxx.com</code> 下建立的 <code>cookie</code> 也可以在 <code>a.xxx.com</code> 下访问到。</p> <p><code>cookie</code> 还具有<code>path</code>属性，如果<code>http://www.a.com/dir1/index.html</code> 建立了一个<code>cookie</code>，那么在<code>http://www.a.com/dir1/</code>目录里的所有页面，以及该目录下面任何子目录里的页面都可以访问这个<code>cookie</code>。但是，如果<code>http://www.a.com/dir2/pages/</code> 需要访问<code>http://www.a.com/dir1/index.html设置的cookes</code>，该怎么办？这时，我们要把<code>cookie</code>的<code>path</code>属性设置成<code>“/”</code>。在指定路径的时候，凡是来自同一服务器，URL里有相同路径的所有WEB页面都可以共享<code>cookies</code>。现在看另一个例子：如果想让 <code>http://www.a.com/dir1/devices/</code> 和<code>http://www.a.com/dir1/users/</code>共享<code>cookie</code>，就要把<code>path</code>设成<code>“/dir1”</code>。</p> <h2 id="跨窗口的通信"><a href="#跨窗口的通信" aria-hidden="true" class="header-anchor">#</a> 跨窗口的通信</h2> <p><code>iframe</code>窗口和<code>window.open</code>打开的窗口若与父窗口不是同源的，都无法与创建它们的父窗口通信，无法互相访问对方的<code>document</code>对象。如果两个窗口一级域名相同，二级域名不同，可以通过设置 <code>document.domain</code> 解决。与<code>cookie</code> 设置 <code>document.domain</code> 的方式一致。</p> <p>但是对于完全不同源（没有相同的一级域名）的情况下，可以通过以下办法实现通信。</p> <h3 id="使用hash"><a href="#使用hash" aria-hidden="true" class="header-anchor">#</a> 使用hash</h3> <p>使用hash，location.hash的变化不会刷新页面。因此发信息的窗口可以把信息以hash的形式写入接收信息窗口的location中，从而达到通信的目的。</p> <h3 id="使用window-name"><a href="#使用window-name" aria-hidden="true" class="header-anchor">#</a> 使用window.name</h3> <p>使用window.name。window.name的值在不同的页面（甚至不同域）加载之后依然存在，并且最大值可以达到2MB。具体的使用方式是。</p> <div class="language- extra-class"><pre class="language-text"><code>1.在窗口A中动态添加一个iframe，将其src设置为窗口B地址。
2.iframe添加了窗口B的页面，窗口B将要发送的消息写入到了window.name中。
3.由于同源策略的原因，此时在窗口A中访问窗口B这个iframe的window对象会跨域，所以此时将iframe的src改成一个与窗口A同域的地址
4.此时窗口A再去读取iframe的window对象的name属性，至此就接收到了窗口B发送的信息。
</code></pre></div><h3 id="window-postmessage"><a href="#window-postmessage" aria-hidden="true" class="header-anchor">#</a> window.postMessage</h3> <p><code>postMessage</code> 是 <code>HTML5</code> 引入的新的API，允许两个窗口通信，即便它们不符合同源策略。</p> <div class="language-js extra-class"><pre class="language-js"><code>otherWindow<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> targetOrigin<span class="token punctuation">,</span> <span class="token punctuation">[</span>transfer<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>otherWindow 其他窗口的一个引用，比如 iframe 的 contentWindow属性、或者是执行了window.open返回的窗口对象，或者是命名过或者是数值索引的window.frames。</li> <li>message 将要发送到其他窗口的数据，它将会被结构化克隆算法序列化。这意味着我们可以不受限制的将数据对象安全的传送给目标窗口而不需要自己去序列化。</li> <li>targetOrigin 通过窗口的origin属性来指定那些窗口可以收到消息事件。其值可以是字符串'*'表示无限制或者是一个URI。在发送消息的时候，如果目标窗口的协议、主机或者端口这三者任意一项不匹配 targetOrigin 的值，那么消息就不会发送成功。</li> <li>transfer 是一串和message同时传递的Transferable对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li></ul> <p>在使用 <code>window.addEventListener('message', function(e){})</code> 就可以监听到其他窗口发送给当前窗口的信息，其中 <code>e.source</code> 表示当前的发送方。比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	e<span class="token punctuation">.</span>source<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'你好，我收到发送的消息了'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这样，就可以给发送方回复消息。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.7b18d2f0.js" defer></script><script src="/assets/js/27.4b3a213a.js" defer></script>
  </body>
</html>
