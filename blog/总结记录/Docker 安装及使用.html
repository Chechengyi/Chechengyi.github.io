<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 使用 | 车程一的博客</title>
    <meta name="description" content="车程一的博客">
    <link rel="icon" href="/vue-logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fbf6f8b.css" as="style"><link rel="preload" href="/assets/js/app.7b18d2f0.js" as="script"><link rel="preload" href="/assets/js/28.eb31cdf1.js" as="script"><link rel="prefetch" href="/assets/js/10.ea08bc69.js"><link rel="prefetch" href="/assets/js/11.59d62fd9.js"><link rel="prefetch" href="/assets/js/12.426af9d7.js"><link rel="prefetch" href="/assets/js/13.b2bd6144.js"><link rel="prefetch" href="/assets/js/14.1790ff5e.js"><link rel="prefetch" href="/assets/js/15.584f93ea.js"><link rel="prefetch" href="/assets/js/16.659d2a43.js"><link rel="prefetch" href="/assets/js/17.7825b058.js"><link rel="prefetch" href="/assets/js/18.0b08fef9.js"><link rel="prefetch" href="/assets/js/19.c553a9ae.js"><link rel="prefetch" href="/assets/js/2.ef1579f9.js"><link rel="prefetch" href="/assets/js/20.1a95086a.js"><link rel="prefetch" href="/assets/js/21.57c66887.js"><link rel="prefetch" href="/assets/js/22.3570ca0d.js"><link rel="prefetch" href="/assets/js/23.7fe8ebe9.js"><link rel="prefetch" href="/assets/js/24.5c706192.js"><link rel="prefetch" href="/assets/js/25.d8757158.js"><link rel="prefetch" href="/assets/js/26.8399a71b.js"><link rel="prefetch" href="/assets/js/27.4b3a213a.js"><link rel="prefetch" href="/assets/js/29.577144a6.js"><link rel="prefetch" href="/assets/js/3.62eea2c7.js"><link rel="prefetch" href="/assets/js/30.ef956d23.js"><link rel="prefetch" href="/assets/js/31.2e8ab40d.js"><link rel="prefetch" href="/assets/js/32.9d1685a0.js"><link rel="prefetch" href="/assets/js/33.d800be4d.js"><link rel="prefetch" href="/assets/js/34.85d350fe.js"><link rel="prefetch" href="/assets/js/35.1625e166.js"><link rel="prefetch" href="/assets/js/36.5cf7699d.js"><link rel="prefetch" href="/assets/js/37.0437fe8d.js"><link rel="prefetch" href="/assets/js/38.ca058290.js"><link rel="prefetch" href="/assets/js/39.d4f95e20.js"><link rel="prefetch" href="/assets/js/4.91c625b2.js"><link rel="prefetch" href="/assets/js/40.211acfac.js"><link rel="prefetch" href="/assets/js/41.a5df0168.js"><link rel="prefetch" href="/assets/js/42.6318b490.js"><link rel="prefetch" href="/assets/js/43.a6543bac.js"><link rel="prefetch" href="/assets/js/44.b04565e5.js"><link rel="prefetch" href="/assets/js/45.3bb1a5c1.js"><link rel="prefetch" href="/assets/js/46.15ed4362.js"><link rel="prefetch" href="/assets/js/47.e838dcd2.js"><link rel="prefetch" href="/assets/js/48.0a220d6c.js"><link rel="prefetch" href="/assets/js/49.a81b7774.js"><link rel="prefetch" href="/assets/js/5.a6bc510c.js"><link rel="prefetch" href="/assets/js/50.5ae2a1df.js"><link rel="prefetch" href="/assets/js/51.1e50c0a5.js"><link rel="prefetch" href="/assets/js/52.05832c5b.js"><link rel="prefetch" href="/assets/js/6.edf1ab01.js"><link rel="prefetch" href="/assets/js/7.75a4d63f.js"><link rel="prefetch" href="/assets/js/8.ac427bc7.js"><link rel="prefetch" href="/assets/js/9.7c5ccd0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fbf6f8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">车程一的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>前端实战</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>react理解</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>总结记录</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/总结记录/浏览器渲染过程以及事件循环.html" class="sidebar-link">浏览器渲染过程以及事件循环</a></li><li><a href="/blog/总结记录/Sequelize使用记录.html" class="sidebar-link">Sequelize 使用记录</a></li><li><a href="/blog/总结记录/TCP、http、udp记录.html" class="sidebar-link">TCP、http、udp记录</a></li><li><a href="/blog/总结记录/https 原理与传输.html" class="sidebar-link">https 原理与传输</a></li><li><a href="/blog/总结记录/编写typescript声明文件.html" class="sidebar-link">编写typescript声明文件</a></li><li><a href="/blog/总结记录/Docker 安装及使用.html" class="active sidebar-link">Docker 使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#docker-简介" class="sidebar-link">Docker 简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#镜像、容器" class="sidebar-link">镜像、容器</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#容器" class="sidebar-link">容器</a></li><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#使用-dockerfile-build一个镜像" class="sidebar-link">使用 Dockerfile build一个镜像</a></li><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#将容器-commit-成一个镜像" class="sidebar-link">将容器 commit 成一个镜像</a></li><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#dockerfile语法" class="sidebar-link">Dockerfile语法</a></li><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#docker-数据持久化、共享" class="sidebar-link">Docker 数据持久化、共享</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#方式二：bind-mouting" class="sidebar-link">方式二：Bind Mouting</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/总结记录/Docker 安装及使用.html#docker-compose" class="sidebar-link">docker-compose</a></li></ul></li><li><a href="/blog/总结记录/JS位运算.html" class="sidebar-link">JS位运算</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构算法</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="docker-使用"><a href="#docker-使用" aria-hidden="true" class="header-anchor">#</a> Docker 使用</h1> <h2 id="docker-简介"><a href="#docker-简介" aria-hidden="true" class="header-anchor">#</a> Docker 简介</h2> <p>学习 Docker 的时候，首先映入眼帘的就是 Docker 到底是什么东西，它解决了什么问题。其实这是我们去学习任何一件事情最核心的一个点。接下来根据文章上的一些观点和自己的理解总结一下。</p> <p>首先看这个问题，你觉得学习软件开发，最难的是什么？相信所有人看到这个问题的时候，脑海中都浮现出了自己在编程道路上抓耳挠腮的一段回忆。但是真正要我说起来，我觉得最难的时候，我不禁想起了那还是我在读大二的时候，那时候我想学习世界上最好的语言：PHP。好家伙，上来就是 apache 服务器配置差点给我劝退（最终研究了几天时间配置成功了，但是为什么现在我是前端而不是 PHPer，这就要扯出一个文件扩展名的惨剧了。）</p> <p>这里牵扯出了一个词：环境。即便是对于最老的司机，配置环境仍然是一个很麻烦的事情。而 Docker 的出现，就很好的解决了这个问题。</p> <p>Docker 的安装就不说了，针对不同的系统，网上有丰富的教程</p> <h3 id="镜像、容器"><a href="#镜像、容器" aria-hidden="true" class="header-anchor">#</a> 镜像、容器</h3> <p>镜像和容器，让我去理解，就像是 类和 实例 的关系。我们可以从网络上去下载一个镜像。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker pull nginx
</code></pre></div><p>这行命令的意思是从远端拉取一个 nginx 的镜像。</p> <p>然后在运行：<code>docker images</code>，就可以查看本地的镜像。会发现本地的镜像已经有 nginx 了。</p> <p>这样做默认使用的是 Docker 提供的源，也可以从指定的地方去下载镜像，比如下面这行命令，是网易蜂巢镜像中心提供的：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker pull hub.c.163.com/library/nginx
<span class="token comment">#docker images [options] [REPOSITORY[:TAG]]</span>

</code></pre></div><p>有下载就有删除，删除一个或者多个容器的命令为：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker rmi <span class="token punctuation">[</span>IMAGE ID<span class="token punctuation">]</span>
<span class="token comment">#docker rmi 46102226f2fd</span>
</code></pre></div><p>需要注意的是，删除镜像的时候需要保证所有基于此镜像的创造的容器都已经删除掉了。</p> <h2 id="容器"><a href="#容器" aria-hidden="true" class="header-anchor">#</a> 容器</h2> <ul><li>运行一个容器，运行一个容器是需要基于镜像的。</li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>docker run --name myNginx -p 9090:80 -d 46102226f2fd
</code></pre></div><p>这行命令的意思是，机遇 <code>ImageId</code> 为 46102226f2fd 的镜像创建一个容器名为：myNginx 并且运行，并将本地的 9090 端口映射到 Docker 容器的 80 端口（这里的nginx启动以后运行在80端口下）。此时访问：<code>localhost:9090</code> 就能看到 nginx 的欢迎界面。</p> <p>运行 <code>dockdr ps</code> 可以看到正在运行的容器：</p> <p><img src="https://s3.ax1x.com/2020/12/07/Dx6sv4.png" alt></p> <ul><li><p>查看所有容器：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker <span class="token function">ps</span> -a
</code></pre></div></li> <li><p>进入容器命令行：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker <span class="token function">exec</span> -it <span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token function">bash</span>

docker <span class="token function">exec</span> -it <span class="token punctuation">[</span>id<span class="token punctuation">]</span> /bin/sh

docker <span class="token function">exec</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token punctuation">[</span>命令<span class="token punctuation">]</span>
</code></pre></div></li></ul> <p>删除容器（可以删除一个或者多个）：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker <span class="token function">rm</span> -f <span class="token punctuation">[</span>CONTAINER ID<span class="token punctuation">]</span>
</code></pre></div><p>更多命令可以查看：<a href="https://www.runoob.com/docker/docker-start-stop-restart-command.html" target="_blank" rel="noopener noreferrer">docker命令大全<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="使用-dockerfile-build一个镜像"><a href="#使用-dockerfile-build一个镜像" aria-hidden="true" class="header-anchor">#</a> 使用 Dockerfile build一个镜像</h2> <p>我们可以制作自己的镜像。接下来制作一个很简单的镜像，首先，新建一个文件夹，随便命名，在文件夹里新建一个 <code>app.js</code> 文件，内容很简单，写上一行 <code>console.log('hello world')</code>。</p> <p>然后在新建一个 <code>Dockerfile</code> 文件，内容如下：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token comment"># 基于什么镜像  如果什么都不依赖就是base image，这里就填 scratch</span>
FROM node<span class="token punctuation">:</span>12.18.0<span class="token punctuation">-</span>buster<span class="token punctuation">-</span>slim 
ADD app.js /
CMD <span class="token punctuation">[</span><span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;app.js&quot;</span><span class="token punctuation">]</span> <span class="token comment"># 容器运行的时候执行的命令</span>
</code></pre></div><p>然后打开命令行工具，执行以下命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker build -t chechengyi/hello <span class="token keyword">.</span>
<span class="token comment"># . 代表在当前文件夹下寻找 Dockerfile 文件</span>
</code></pre></div><p>然后可以看到控制台显示了该镜像build的过程，由于需要 node:12.18.0-buster-slim 这个镜像，时间可能会比较久。build 完成之后，执行 <code>docker images</code> 就可以看到该镜像已经制作成功了。</p> <p><img src="https://s3.ax1x.com/2020/12/09/rCeb7R.png" alt></p> <h2 id="将容器-commit-成一个镜像"><a href="#将容器-commit-成一个镜像" aria-hidden="true" class="header-anchor">#</a> 将容器 commit 成一个镜像</h2> <p>前面讲的方法是使用 <code>Dockerfile</code> 去build 一个镜像。现在考虑这样一个场景，我现在想要建立一个有 nginx 的镜像，这个需求很简单，我们只需要从源上pull一个 nginx 的 image 下来就可以了。可是我想对这个 nginx 做一些配置，然后创建一个镜像方便以后使用。这时候，可以将容器 commit 成一个镜像了。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker commit <span class="token punctuation">[</span>container<span class="token punctuation">]</span> <span class="token punctuation">[</span>image name<span class="token punctuation">]</span>
<span class="token comment"># docker commit hello chechengyi/hello2</span>
</code></pre></div><p>但是还是建议都使用 <code>Dockerfile</code> 的方式去 build 镜像。</p> <h2 id="dockerfile语法"><a href="#dockerfile语法" aria-hidden="true" class="header-anchor">#</a> Dockerfile语法</h2> <ul><li><h4 id="from"><a href="#from" aria-hidden="true" class="header-anchor">#</a> FROM</h4> <div class="language-yaml extra-class"><pre class="language-yaml"><code>FROM scratch <span class="token comment">#制作 base image</span>
FROM centos  <span class="token comment">#使用 base image</span>
FORM ubuntu<span class="token punctuation">:</span><span class="token number">14.04 </span><span class="token comment"># 使用 image</span>
</code></pre></div></li> <li><h4 id="label"><a href="#label" aria-hidden="true" class="header-anchor">#</a> LABEL</h4> <div class="language-yaml extra-class"><pre class="language-yaml"><code>LABEL maintainer = &quot;984593931@qq.com&quot;
LABEL version = &quot;1.0&quot;
LABEL description = &quot;描述&quot;
</code></pre></div></li> <li><h4 id="run-运行命令"><a href="#run-运行命令" aria-hidden="true" class="header-anchor">#</a> RUN  运行命令</h4></li></ul> <p>运行命令的时候 Docker会创建一个容器，以此获得文件的读写权</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>RUN npm install &amp;&amp; npm run build \
		node index.js.  <span class="token comment"># 反斜线换行</span>
</code></pre></div><p>每 run 一层就会创建一个容器、多一个分层，为了避免无用分层，所以尽量少run，多个命令用 \ 换行分开</p> <ul><li><h4 id="workdir"><a href="#workdir" aria-hidden="true" class="header-anchor">#</a> WORKDIR</h4> <p>设定当前工作目录</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>WORKDIR /test  <span class="token comment"># 如果没有会自动创建目录</span>
WORKDIR demo
RUN pwd        <span class="token comment"># 输出结果为 test/demo</span>
</code></pre></div></li> <li><h4 id="add-copy"><a href="#add-copy" aria-hidden="true" class="header-anchor">#</a> ADD  COPY</h4> <p>将当前目录的文件 ADD 或者 COPY 到 image</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>ADD hello / <span class="token comment"># 将 hello 添加到 image 的根目录</span>
ADD test.tar.gz / <span class="token comment"># 添加到根目录并且解压</span>

WORKDIR /root
ADD hello.html test/  <span class="token comment"># 将 hello.html 添加到 root/test/hello</span>

WORKDIR /root
COPY hello test/ <span class="token comment"># 将 hello.html 复制到 root/test/hello</span>

</code></pre></div></li> <li><h4 id="env"><a href="#env" aria-hidden="true" class="header-anchor">#</a> ENV</h4> <p>设置一些常量</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>ENV USERNAME chechengyi <span class="token comment"># 设置常量</span>
RUN echo &quot;$<span class="token punctuation">{</span>USERNAME<span class="token punctuation">}</span>&quot;  <span class="token comment"># 引用常量</span>
</code></pre></div></li> <li><h4 id="run、entrypoint"><a href="#run、entrypoint" aria-hidden="true" class="header-anchor">#</a> RUN、ENTRYPOINT</h4> <p>**RUN：**设置容器启动后默认执行的命令和参数；<strong>ENTRYPOIN：</strong> 设置容器启动时运行的命令</p> <ol><li><p>Shell 格式</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>RUN npm install
CMD echo &quot;hello world&quot; <span class="token comment"># 如果定义了多个CMD 只有最后一个会执行， 如果docker run指定了其他命令，CMD会被忽略</span>
ENTRYPOINT echo &quot;hello&quot;
<span class="token comment"># ENTRYPOINT 让容器以应用程序或者服务的形式运行，不会被忽略，一定会执行。</span>

</code></pre></div></li> <li><p>Exec 格式</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>RUN <span class="token punctuation">[</span><span class="token string">&quot;npm&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;install&quot;</span><span class="token punctuation">]</span>
CMD <span class="token punctuation">[</span><span class="token string">&quot;/bin/echo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">]</span>
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;/bin/bash&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;echo hello world&quot;</span><span class="token punctuation">]</span>
</code></pre></div></li></ol></li></ul> <h2 id="docker-数据持久化、共享"><a href="#docker-数据持久化、共享" aria-hidden="true" class="header-anchor">#</a> Docker 数据持久化、共享</h2> <ul><li><p>使用场景：有些容器在运行的过程中可能会产生一些数据，比如 mysql 的容器在存储的过程中势必会产生一些文件，这时候如果数据只是存在容器中，如果容器被删除掉了数据也会消失。所以这时候想要将数据持久化到容器以外的地方。</p></li> <li><p>受管理的 data Volume，由 Docker 后台自动创建</p></li> <li><p>绑定挂载的 Volume，具体挂载位置可以由用户指定</p></li></ul> <div class="language-bash extra-class"><pre class="language-bash"><code>docker volume <span class="token function">ls</span>  // 查看当前所有的 volume
docker volume <span class="token function">rm</span> <span class="token punctuation">[</span>id<span class="token punctuation">]</span> // 删除某个 volume
docker volume inspect <span class="token punctuation">[</span>id<span class="token punctuation">]</span> //查看某个 volume 的具体信息
</code></pre></div><h4 id="方式1-data-volume"><a href="#方式1-data-volume" aria-hidden="true" class="header-anchor">#</a> 方式1: Data Volume</h4> <p>比如在启 mysql 容器的时候：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker run -d -v mysql:/var/lib/mysql --name mysql -e MYSQL_ALLOW_EMPTY_PASSWORD<span class="token operator">=</span>true mysql
</code></pre></div><p>然后执行 <code>docker volume ls</code>，就可以看待此时创建了一个 <code>VOLUME NAME</code> 为 mysql 的 volume：</p> <p><img src="https://s3.ax1x.com/2020/12/11/rkIMGV.png" alt></p> <p>然后查看一下这个 volume 的信息 <code>docker volume inspect mysql</code> ：</p> <p><img src="https://s3.ax1x.com/2020/12/11/rkIrse.png" alt></p> <p>可以看到，这样 mysql 最终被储存的位置就是宿主机的 <code>/var/lib/docker/volumes/mysql/_data</code> 处，这样即使容器被删除掉了，数据也得以继续保存，下一次创建 mysql 容器的时候再次指定 volume 为 mysql，就可以继续使用之前存储的数据。</p> <h3 id="方式二：bind-mouting"><a href="#方式二：bind-mouting" aria-hidden="true" class="header-anchor">#</a> 方式二：Bind Mouting</h3> <p>之前介绍的特性是，在 mysql 存储的时候，将容器内部的文件映射到宿主机，以实现在容器删除的时候容器运行的时候保存的数据依然保留。而 Bind Mouting 在我看来，意义就是保证宿主机的文件和容器的文件是同步的，也就是我对于宿主机文件的改变会映射到容器当中。接下来介绍一个例子。</p> <p>首先编写一个 <code>Dockerfile</code> 用来构建一个 nginx 的镜像，内容如下：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code>FROM nginx  <span class="token comment"># 基于 nginx 镜像</span>

WORKDIR /usr/share/nginx/html <span class="token comment"># 工作目录</span>

COPY index.html index.html <span class="token comment"># 讲当前文件夹的 index.html 文件复制到 容器 /usr/share/nginx/html</span>
</code></pre></div><p>然后执行命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker build -t chechengyi/nginx <span class="token keyword">.</span> <span class="token comment"># 执行当前文件夹下的 Dockerfile 文件生成一个镜像 命名为chechengyi.nginx</span>
</code></pre></div><p>然后启动容器，执行：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker run -d  --name myNginx -v <span class="token variable"><span class="token variable">$(</span><span class="token function">pwd</span><span class="token variable">)</span></span>:/usr/share/nginx/html  -p 9090:80 db590c2c3886
</code></pre></div><p>关键在于这个 -v 参数，它将 <code>${pwd}</code> （当前目录的地址）与 容器的 <code>/usr/share/nginx/html</code> 关联了，这时改当前目录下的文件也会映射到容器的 <code>/usr/share/nginx/html</code> 中。这样修改宿主机中的 <code>index.html</code> 文件，容器中的 <code>index.html</code> 文件也会改变。Bind Mouting 的特性可以用于实现代码部署。</p> <p>或者我们不想去写一个这么长的命令，这时候可以借助 <code>docker-compose</code> 去实现。在当前目录写下一个 <code>docker-compose.yml</code> 文件，内容如下：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">my-nginx</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> 
      <span class="token key atrule">context</span><span class="token punctuation">:</span> .
      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> Dockerfile
    <span class="token comment"># image: chechengyi/nginx #如果nginx服务器的镜像已经构建好了就直接使用，否则使用build先构建镜像</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> 
      <span class="token punctuation">-</span> ./<span class="token punctuation">:</span>/usr/share/nginx/html <span class="token comment"># 映射目录</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span> 
      <span class="token punctuation">-</span> &quot;9090<span class="token punctuation">:</span>80&quot;  <span class="token comment"># 映射端口</span>
</code></pre></div><p>然后在执行：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker-compose up -d --build
<span class="token comment"># 加 -d 代表在后台容器服务 -build 表示在启动容器前构建镜像</span>
</code></pre></div><h2 id="docker-compose"><a href="#docker-compose" aria-hidden="true" class="header-anchor">#</a> docker-compose</h2> <p>在许多实际的项目跑起来后，不只具有一个两个容器，而且有些容器之间可能还具有 link 的关系。这个时候再在命令行一个一个的去敲代码启动容器就会显得很麻烦，docker-compose 可以很好的解决这个问题。</p> <p>首先要去新建一个 <code>docker-compose.yml</code> 文件，接下来写下一份配置文件并且写上注释：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> &quot;3&quot; <span class="token comment"># 版本</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>  
  <span class="token key atrule">ziwu-server</span><span class="token punctuation">:</span> <span class="token comment"># 容器</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./ziwu<span class="token punctuation">-</span>server<span class="token punctuation">-</span>app/. <span class="token comment"># 使用 Dockerfile先构建镜像在构建容器，这里是Dockerfile的目录</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./ziwu<span class="token punctuation">-</span>server<span class="token punctuation">-</span>app/ziwu<span class="token punctuation">-</span>server<span class="token punctuation">:</span>/ziwu<span class="token punctuation">-</span>server <span class="token comment"># Bind Mouting 映射文件</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span> <span class="token comment"># 端口映射</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;3000:7001&quot;</span> 
    <span class="token key atrule">links</span><span class="token punctuation">:</span> <span class="token comment"># 容器link</span>
      <span class="token punctuation">-</span> mysql
  <span class="token key atrule">mysql</span><span class="token punctuation">:</span> <span class="token comment"># mysql 服务</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql <span class="token comment"># 基于什么镜像</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> &quot;3306<span class="token punctuation">:</span>3306&quot; <span class="token comment"># 端口映射</span>
    <span class="token key atrule">environment</span><span class="token punctuation">:</span> <span class="token comment"># 设置变量</span>
      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> xxxxx
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># 映射 Data Volume</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;mysql-data:/var/lib/mysql&quot;</span>
<span class="token key atrule">volumes</span><span class="token punctuation">:</span> <span class="token comment"># Data Volume 的定义</span>
  <span class="token key atrule">mysql-data</span><span class="token punctuation">:</span>  

</code></pre></div><p>然后执行命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>docker-compose up -d --build
<span class="token comment"># 加 -d 代表在后台容器服务 -build 表示在启动容器前构建镜像</span>
</code></pre></div><p><img src="https://s3.ax1x.com/2020/12/11/rAlx3Q.png" alt></p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.7b18d2f0.js" defer></script><script src="/assets/js/28.eb31cdf1.js" defer></script>
  </body>
</html>
