<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>react整体更新的流程 | 车程一的博客</title>
    <meta name="description" content="车程一的博客">
    <link rel="icon" href="/vue-logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fbf6f8b.css" as="style"><link rel="preload" href="/assets/js/app.7b18d2f0.js" as="script"><link rel="preload" href="/assets/js/10.ea08bc69.js" as="script"><link rel="prefetch" href="/assets/js/11.59d62fd9.js"><link rel="prefetch" href="/assets/js/12.426af9d7.js"><link rel="prefetch" href="/assets/js/13.b2bd6144.js"><link rel="prefetch" href="/assets/js/14.1790ff5e.js"><link rel="prefetch" href="/assets/js/15.584f93ea.js"><link rel="prefetch" href="/assets/js/16.659d2a43.js"><link rel="prefetch" href="/assets/js/17.7825b058.js"><link rel="prefetch" href="/assets/js/18.0b08fef9.js"><link rel="prefetch" href="/assets/js/19.c553a9ae.js"><link rel="prefetch" href="/assets/js/2.ef1579f9.js"><link rel="prefetch" href="/assets/js/20.1a95086a.js"><link rel="prefetch" href="/assets/js/21.57c66887.js"><link rel="prefetch" href="/assets/js/22.3570ca0d.js"><link rel="prefetch" href="/assets/js/23.7fe8ebe9.js"><link rel="prefetch" href="/assets/js/24.5c706192.js"><link rel="prefetch" href="/assets/js/25.d8757158.js"><link rel="prefetch" href="/assets/js/26.8399a71b.js"><link rel="prefetch" href="/assets/js/27.4b3a213a.js"><link rel="prefetch" href="/assets/js/28.eb31cdf1.js"><link rel="prefetch" href="/assets/js/29.577144a6.js"><link rel="prefetch" href="/assets/js/3.62eea2c7.js"><link rel="prefetch" href="/assets/js/30.ef956d23.js"><link rel="prefetch" href="/assets/js/31.2e8ab40d.js"><link rel="prefetch" href="/assets/js/32.9d1685a0.js"><link rel="prefetch" href="/assets/js/33.d800be4d.js"><link rel="prefetch" href="/assets/js/34.85d350fe.js"><link rel="prefetch" href="/assets/js/35.1625e166.js"><link rel="prefetch" href="/assets/js/36.5cf7699d.js"><link rel="prefetch" href="/assets/js/37.0437fe8d.js"><link rel="prefetch" href="/assets/js/38.ca058290.js"><link rel="prefetch" href="/assets/js/39.d4f95e20.js"><link rel="prefetch" href="/assets/js/4.91c625b2.js"><link rel="prefetch" href="/assets/js/40.211acfac.js"><link rel="prefetch" href="/assets/js/41.a5df0168.js"><link rel="prefetch" href="/assets/js/42.6318b490.js"><link rel="prefetch" href="/assets/js/43.a6543bac.js"><link rel="prefetch" href="/assets/js/44.b04565e5.js"><link rel="prefetch" href="/assets/js/45.3bb1a5c1.js"><link rel="prefetch" href="/assets/js/46.15ed4362.js"><link rel="prefetch" href="/assets/js/47.e838dcd2.js"><link rel="prefetch" href="/assets/js/48.0a220d6c.js"><link rel="prefetch" href="/assets/js/49.a81b7774.js"><link rel="prefetch" href="/assets/js/5.a6bc510c.js"><link rel="prefetch" href="/assets/js/50.5ae2a1df.js"><link rel="prefetch" href="/assets/js/51.1e50c0a5.js"><link rel="prefetch" href="/assets/js/52.05832c5b.js"><link rel="prefetch" href="/assets/js/6.edf1ab01.js"><link rel="prefetch" href="/assets/js/7.75a4d63f.js"><link rel="prefetch" href="/assets/js/8.ac427bc7.js"><link rel="prefetch" href="/assets/js/9.7c5ccd0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fbf6f8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">车程一的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>前端实战</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>react理解</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/react理解/生命周期详解.html" class="sidebar-link">生命周期详解</a></li><li><a href="/blog/react理解/react整体更新流程.html" class="active sidebar-link">react整体更新的流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_1-setstate方法" class="sidebar-link">1 setState方法</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_2-schedulework" class="sidebar-link">2 scheduleWork</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_3-performunitofwork" class="sidebar-link">3 performUnitOfWork</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_3-1-beginwork" class="sidebar-link">3.1 beginWork</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_3-2-reconcilechildren" class="sidebar-link">3.2 reconcileChildren</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_3-3-completeunitofwork" class="sidebar-link">3.3 completeUnitOfWork</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/react理解/react整体更新流程.html#_4-commitroot" class="sidebar-link">4 commitRoot</a></li></ul></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>总结记录</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构算法</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="react整体更新的流程"><a href="#react整体更新的流程" aria-hidden="true" class="header-anchor">#</a> react整体更新的流程</h1> <p>假设我们现在的 <code>react</code> 应用的初次渲染后整体结构是以下所示：</p> <img src="https://s1.ax1x.com/2020/09/20/wToyp4.png" style="zoom:80%;"> <p>这里假设的情景是，class组件Fu中拥有一个state，是一个数组，数组中拥有三个元素，它的三个子元素就是根据这个数组渲染而来，然后当组件Fu中，执行了setState操作，删除掉了数组中的某一项元素，整个过程中将会发生什么样的事情呢？</p> <h2 id="_1-setstate方法"><a href="#_1-setstate方法" aria-hidden="true" class="header-anchor">#</a> 1 setState方法</h2> <p>在使用 ES6的语法， react编写一个classComponent式的组件的时候，都要继承 <code>React.Component</code>，正式由于继承了它，我们所编写的 classComponent 才拥有了 setState 方法。那么实际上，react提供的 setState方法，到底是做了什么事情呢？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> context<span class="token punctuation">,</span> updater<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>
  <span class="token comment">// If a component has string refs, we will assign a different object later.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>refs <span class="token operator">=</span> emptyObject<span class="token punctuation">;</span>
  <span class="token comment">// We initialize the default updater but the real one gets injected by the</span>
  <span class="token comment">// renderer.</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater <span class="token operator">=</span> updater <span class="token operator">||</span> ReactNoopUpdateQueue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Component<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>partialState<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">invariant</span><span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span>
      <span class="token keyword">typeof</span> partialState <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">||</span>
      partialState <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    <span class="token string">'setState(...): takes an object of state variables to update or a '</span> <span class="token operator">+</span>
      <span class="token string">'function which returns an object of state variables.'</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>很明显的看到，setState的时候，实际上是执行了react所提供的一个对象的 <code>enqueueSetState</code> 方法，并且传入了当前组件实例、将要更新成的对象、更新完成后的回调函数。</p> <p>而这个对象，在组建第一次更新，实例化组件的时候才真正的被传入。它的代码在 react-reconciler包下面的。</p> <p>注入的地方在：<code>beginWork</code> 方法里面 <code>updateClassComponent</code> 的时候，调用到了 <code>adoptClassInstance</code> 方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">adoptClassInstance</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> instance<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  instance<span class="token punctuation">.</span>updater <span class="token operator">=</span> classComponentUpdater<span class="token punctuation">;</span> <span class="token comment">// 在这里注入的</span>
  workInProgress<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> instance<span class="token punctuation">;</span>
  <span class="token comment">// The instance needs access to the fiber so that it can schedule updates</span>
  <span class="token function">setInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">,</span> workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    instance<span class="token punctuation">.</span>_reactInternalInstance <span class="token operator">=</span> fakeInternalInstance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ReactFiberClassComponent.js 文件中。它其实提供了三个方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> classComponentUpdater <span class="token operator">=</span> <span class="token punctuation">{</span>
  enqueueSetState<span class="token punctuation">,</span> <span class="token comment">// setState 对应执行的方法</span>
  enqueueReplaceState<span class="token punctuation">,</span> <span class="token comment">// 暂时没用过，不清楚其作用</span>
  enqueueForceUpdate <span class="token comment">// forceUpdate对应执行的方法</span>
<span class="token punctuation">}</span>
</code></pre></div><p>大致的总结一下此过程就是，react在初始化classComponent的实例时，为其传入了一个updater对象，setState的时候执行了其 <code>enqueueSetState</code> 方法，该方法所做的事情就是，首先，通过实例找到了当前这个组件所对应的Fiber对象，然后生成了一个 expirationTime(有关任务优先级)，根据 expirationTime 创建了一个 Update对象然后把这个 Update对象添加到了当前Fiber节点的更新队列中（使用的是链表去存储）。然后调用了 <code>scheduleWork</code> 方法，传入了当前Fiber对象和当前任务的 expirationTime。</p> <h2 id="_2-schedulework"><a href="#_2-schedulework" aria-hidden="true" class="header-anchor">#</a> 2 scheduleWork</h2> <p>执行到这个方法后，真正打开了react开始一整套更新过程的大门。</p> <blockquote><p>对不起，因为这篇文章很大程度上是写给我自己看的，而我已经了解过react Fiber架构。如果有其他人看到并且认为该文章可以对你产生帮助想要继续往下阅读，我假设你已经理解了react Fiber 架构。</p></blockquote> <p><code>scheduleWork</code> 方法首先第一行就调用了 <code>scheduleWorkToRoot</code> 方法，目的，设置当前发起更新的Fiber节点的 <code>expirationTime</code> 以及其祖先节点的 <code>childExpirationTime</code> 。然后返回了一个root节点，这就是当前Fiber节点的根节点。然后调用了 <code>requestWork</code> 方法，传入了当前根节点。</p> <p>然后 <code>requestWork</code> 将当前的 root 节点加入到了一个队列之中。为什么要使用一个队列去管理呢？因为实际的使用情况中很有可能不只一次的使用了 <code>ReactDom.render</code> 这个api。所以脑海里应该能想象出这样一副场景：</p> <p><img src="https://s1.ax1x.com/2020/09/20/wTq5SU.png" alt></p> <p>执行了setState后，发起更新的Fiber节点的根节点被存储在队列中等待更新，然后每一次查找都是从这个Root开始，如果当前节点的 <code>childExpirationTime</code> 有值，那么当前节点的子节点肯定存在更新，这里在判断的时候react就会做优化、因为不管触发更新的地方在哪里，都是从root开始找，如果当前节点没有更新其子节点也没有更新的话，就可以跳过不用在查找其后代元素。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">requestWork</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> FiberRoot<span class="token punctuation">,</span> expirationTime<span class="token punctuation">:</span> ExpirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">addRootToSchedule</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isRendering<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Prevent reentrancy. Remaining work will be scheduled at the end of</span>
    <span class="token comment">// the currently rendering batch.</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isBatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Flush work at the end of the batch.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isUnbatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...unless we're inside unbatchedUpdates, in which case we should</span>
      <span class="token comment">// flush it now.</span>
      nextFlushedRoot <span class="token operator">=</span> root<span class="token punctuation">;</span>
      nextFlushedExpirationTime <span class="token operator">=</span> Sync<span class="token punctuation">;</span>
      <span class="token function">performWorkOnRoot</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> Sync<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// TODO: Get rid of Sync and use current time?</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>expirationTime <span class="token operator">===</span> Sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performSyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">scheduleCallbackWithExpirationTime</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> expirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>react比较重要的批量更新的判定，也是在 <code>requestWork</code> 中所做的。可以看到代码中，中断的地方有两处，一处是如果 <code>isRendering</code> 为true，一处是 <code>isBatchingUpdates</code> 也就是处于批量更新中。 当react出发合成事件时，就会先去设置 <code>isBatchingUpdates</code> 相关的变量。所以这是为什么 在合成事件中，同时setState几次，react表现为异步的原因。在 <code>componentDidMount</code> 生命周期中同时setState几次，表现也是异步的，但是这是被这里的另外一个条件打断的，也就是 <code>isRendering</code> 为true了，代表react的上一次的更新还没有结束。（在<code>componentDidMount</code> 勾子被处罚的时候，react正处于commting阶段，这个阶段的 <code>isRendering</code> 变量为true）</p> <h2 id="_3-performunitofwork"><a href="#_3-performunitofwork" aria-hidden="true" class="header-anchor">#</a> 3 performUnitOfWork</h2> <p>之前的工作中，react已经将要更新的root推入到队列之中，接下来就是要开始更新。 由于存储的是root节点，所以一开始找到的节点是react应用最上层的节点，就是那个 <code>&lt;App /&gt;</code>。 React 首选所做的工作是：调和子节点。</p> <p>比如react应用初次渲染的时候，那时候整个应用对应的Fiber结构还没有生成，生成整个应用所对应的Fiber树就是在调和子节点的过程中完成的。但是我们思路跟着今天的例子，更新来讲。</p> <p><code>performUnitOfWork</code> 里调用了一个很关键的方法：<code>beginWork</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span>isYieldy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isYieldy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Flush work without yielding</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextUnitOfWork <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>nextUnitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Flush asynchronous work until there's a higher priority event</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYieldToRenderer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      nextUnitOfWork <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>nextUnitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token operator">...</span>
  next <span class="token operator">=</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> nextRenderExpirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调和</span>
  workInProgress<span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>pendingProps<span class="token punctuation">;</span>
  <span class="token operator">...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// If this doesn't spawn new work, complete the current work.</span>
    next <span class="token operator">=</span> <span class="token function">completeUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  ReactCurrentOwner<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 提交</span>

  <span class="token keyword">return</span> next
<span class="token punctuation">}</span>
</code></pre></div><p><code>beginWork</code> 所返回的 next 又是当前 <code>nextUnitOfWork</code> 的第一个子节点。所以其实可以很清晰的看到这就是一个循环的过程，对当前的Fiber节点执行 <code>beginWork</code> 操作，返回当前Fiber节点的第一个子节点，然后又对这个子节点进行 <code>beginWork</code> ，所以，调和子节点其实就是一个至上而下的过程。</p> <h3 id="_3-1-beginwork"><a href="#_3-1-beginwork" aria-hidden="true" class="header-anchor">#</a> 3.1 beginWork</h3> <p><code>beginWork</code> 方法的代码比较多，它做的大概的事情就是，针对不同类型的组件调用其方法对组件进行更新（也有可能是第一次渲染）。之前提到过的react所做的优化，当节点不需要更新（<code>childExpirationTime</code>和 <code>expirationTime</code> 都为null）的情况下直接跳过这个节点。</p> <p>以classComponent为例子，这里最终执行了 <code>updateClassComponent</code> 方法。这个方法的代码也比较多。简单来说，就是如果组件是第一次渲染，就多执行一步：创建实例。还有更新实例（执行一些生命周期方法等）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>componentDidMount <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    workInProgress<span class="token punctuation">.</span>effectTag <span class="token operator">|=</span> Update<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>这里有一点需要注意的是，<code>componentDidMount</code> 生命周期方法并不是在这里立即执行的，而是在当前Fiber节点的</p> <p><code>effectTag</code> 打上了 <code>Update</code> 到最后 <code>commit</code>阶段在处理。</p> <p>然后执行了一个 <code>finishClassComponent</code> 方法，并返回了这个方法所返回的值。简单来说这个方法就是执行了 classCompoennt 的render方法，然后就是比较关键的调和部分了。</p> <h3 id="_3-2-reconcilechildren"><a href="#_3-2-reconcilechildren" aria-hidden="true" class="header-anchor">#</a> 3.2 reconcileChildren</h3> <p><code>reconcileChildren</code> 里分了两种情况，一是组件是第一次渲染，二是组件已经渲染过了。最终都调用了 <code>reconcileChildFibers</code> 方法，不同的是传入的参数中有一个是当前Fiber节点的第一个子节点，针对第一种情况，由于组件是第一次渲染，子组件还没有调和好，所以这里传入的就是null。</p> <p>在这个方法中，针对不同类型的组件又调用了不同的方法。简单一点来说，主要是 <code>reconcileSingleElement</code> ：针对子组件是单个节点所调用的方法，<code>reconcileChildrenArray</code>: 针对子组件是一个数组所调用的方法。这个两个方法的主要作用就是，通过对比key找到可以复用的Fiber节点，如果没有，就新创建一个Fiber节点。</p> <p>对于子节点是数组的情况来说，如果Fiber节点可以复用，那么说明这个节点只是处于更新，如果是新创建了一个Fiber节点，那么说明这个节点是这次新加的。关于这两个方法对比的细节，可以在重新开一篇文章去讲了～</p> <h3 id="_3-3-completeunitofwork"><a href="#_3-3-completeunitofwork" aria-hidden="true" class="header-anchor">#</a> 3.3 completeUnitOfWork</h3> <p>前面说到了，react不断从上到下去调和，然后每次都返回 Fiber.child也就是当前Fiber节点的第一个子节点在重复这个操作，但是react应用的Fiber树总是有限的，当Fiber.child返回null的时候，说明已经没有子节点了。用之前的例子来说就是 <strong>Z1</strong> 节点已经调和完毕了，接下来就要对已经调和完成的节点进行 <code>completeUnitOfWork</code> 操作。</p> <p>针对 <code>hostComponent</code> 如果是第一次渲染，就会创建一个真实的dom节点，然后使用深度优先搜索，将当前子节点的所有真实节点都append进dom节点里面（此时还在内存中操作，所以界面上不会有所体现）。</p> <p>这个方法中比较关键的地方在于对与 <code>effectTag</code> 的处理。总的来说，就是会将当前节点的 <code>lastEffect</code> 和 <code>firstEffect</code> 添加到父节点的 <code>lastEffect</code> 和 <code>firstEffect</code> (这里也是一个链表，<code>firstEffect</code>指向第一个Fiber节点，<code>lastEffect</code> 指向最后一个Fiber节点，Fiber节点的 <code>nextEffect</code>属性指向下一个Fiber节点)。最终，这次更新导致的所有Fiber节点产生的副作用都被传递到了最上一层，在 <code>commit</code> 阶段的时候，只要根据这个链表，就能准确的执行相应Fiber节点的副作用操作。</p> <p>然后这个方法会判断当前Fiber节点的 <code>sibling</code> 属性，也就下一个兄弟节点。如果有兄弟节点，就会返回这个兄弟节点，这意味着下一次又开始对这个兄弟节点开始做 <code>beginWrok</code> 操作。使用之前的例子来说就是：从上至下调和到了Z1节点，Z1节点没有子阶段了，对Z1节点执行complete操作；然后对Z2节点进行调和(beginWork)，Z2节点没有子节点了对Z2节点执行complete操作；然后又开始对Z3(beginWork)节点进行调和，Z3没有子节点了，对Z3进行complete，Z3没有兄弟节点了，对其父节点Fu执行 complete 操作。。。 如果最终到了最顶点，即没有父节点，也没有兄弟节点了(就是那个<App></App>) 说明Fiber树的更新已经完成了，可以进行 <code>commiting</code> 操作了。</p> <h2 id="_4-commitroot"><a href="#_4-commitroot" aria-hidden="true" class="header-anchor">#</a> 4 commitRoot</h2> <p>当Fiber树完成了更新以后，就会进入 <code>commitRoot</code> 阶段。</p> <p>在之前节点的更新的过程中，从上往下调和，从下往上提交，节点涉及到副作用操作的，都不断的向上传递最终到了顶点节点的 <code>effectTag</code> 链条中了，所以，遍历这个队列，就能找到与之相对应的Fiber节点。由此触发对应的一些比如生命周期之前的处理（比如getSnapshotBeforeUpdate就是在生命周期之前先调用的）、然后生命周期的出发也是在这个阶段进行，还有当使用了ref的时候，ref的绑定和卸载都是在这个阶段进行的。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.7b18d2f0.js" defer></script><script src="/assets/js/10.ea08bc69.js" defer></script>
  </body>
</html>
