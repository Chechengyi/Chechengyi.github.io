<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>生命周期详解 | 车程一的博客</title>
    <meta name="description" content="车程一的博客">
    <link rel="icon" href="/vue-logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.2fbf6f8b.css" as="style"><link rel="preload" href="/assets/js/app.7b18d2f0.js" as="script"><link rel="preload" href="/assets/js/13.b2bd6144.js" as="script"><link rel="prefetch" href="/assets/js/10.ea08bc69.js"><link rel="prefetch" href="/assets/js/11.59d62fd9.js"><link rel="prefetch" href="/assets/js/12.426af9d7.js"><link rel="prefetch" href="/assets/js/14.1790ff5e.js"><link rel="prefetch" href="/assets/js/15.584f93ea.js"><link rel="prefetch" href="/assets/js/16.659d2a43.js"><link rel="prefetch" href="/assets/js/17.7825b058.js"><link rel="prefetch" href="/assets/js/18.0b08fef9.js"><link rel="prefetch" href="/assets/js/19.c553a9ae.js"><link rel="prefetch" href="/assets/js/2.ef1579f9.js"><link rel="prefetch" href="/assets/js/20.1a95086a.js"><link rel="prefetch" href="/assets/js/21.57c66887.js"><link rel="prefetch" href="/assets/js/22.3570ca0d.js"><link rel="prefetch" href="/assets/js/23.7fe8ebe9.js"><link rel="prefetch" href="/assets/js/24.5c706192.js"><link rel="prefetch" href="/assets/js/25.d8757158.js"><link rel="prefetch" href="/assets/js/26.8399a71b.js"><link rel="prefetch" href="/assets/js/27.4b3a213a.js"><link rel="prefetch" href="/assets/js/28.eb31cdf1.js"><link rel="prefetch" href="/assets/js/29.577144a6.js"><link rel="prefetch" href="/assets/js/3.62eea2c7.js"><link rel="prefetch" href="/assets/js/30.ef956d23.js"><link rel="prefetch" href="/assets/js/31.2e8ab40d.js"><link rel="prefetch" href="/assets/js/32.9d1685a0.js"><link rel="prefetch" href="/assets/js/33.d800be4d.js"><link rel="prefetch" href="/assets/js/34.85d350fe.js"><link rel="prefetch" href="/assets/js/35.1625e166.js"><link rel="prefetch" href="/assets/js/36.5cf7699d.js"><link rel="prefetch" href="/assets/js/37.0437fe8d.js"><link rel="prefetch" href="/assets/js/38.ca058290.js"><link rel="prefetch" href="/assets/js/39.d4f95e20.js"><link rel="prefetch" href="/assets/js/4.91c625b2.js"><link rel="prefetch" href="/assets/js/40.211acfac.js"><link rel="prefetch" href="/assets/js/41.a5df0168.js"><link rel="prefetch" href="/assets/js/42.6318b490.js"><link rel="prefetch" href="/assets/js/43.a6543bac.js"><link rel="prefetch" href="/assets/js/44.b04565e5.js"><link rel="prefetch" href="/assets/js/45.3bb1a5c1.js"><link rel="prefetch" href="/assets/js/46.15ed4362.js"><link rel="prefetch" href="/assets/js/47.e838dcd2.js"><link rel="prefetch" href="/assets/js/48.0a220d6c.js"><link rel="prefetch" href="/assets/js/49.a81b7774.js"><link rel="prefetch" href="/assets/js/5.a6bc510c.js"><link rel="prefetch" href="/assets/js/50.5ae2a1df.js"><link rel="prefetch" href="/assets/js/51.1e50c0a5.js"><link rel="prefetch" href="/assets/js/52.05832c5b.js"><link rel="prefetch" href="/assets/js/6.edf1ab01.js"><link rel="prefetch" href="/assets/js/7.75a4d63f.js"><link rel="prefetch" href="/assets/js/8.ac427bc7.js"><link rel="prefetch" href="/assets/js/9.7c5ccd0b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2fbf6f8b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">车程一的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div> <a href="https://github.com/chechengyi" target="_blank" rel="noopener noreferrer" class="repo-link">
    我的github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading"><span>前端实战</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>js相关</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading open"><span>react理解</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/react理解/生命周期详解.html" class="active sidebar-link">生命周期详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_1、新老生命周期都存在的" class="sidebar-link">1、新老生命周期都存在的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_1-1-constructor" class="sidebar-link">1.1 constructor</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_1-2-componentdidmount" class="sidebar-link">1.2 componentDidMount</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_1-3-componentdidupdate" class="sidebar-link">1.3 componentDidUpdate</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_1-4-shouldcomponentupdate" class="sidebar-link">1.4 shouldComponentUpdate</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_1-5-componentwillunmount" class="sidebar-link">1.5 componentWillUnMount</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_2新生命周期" class="sidebar-link">2新生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_2-1-getsnapshotbeforeupdate" class="sidebar-link">2.1 getSnapshotBeforeUpdate</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#_2-2-getderivedstatefromprops" class="sidebar-link">2.2 getDerivedStateFromProps</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#将要废弃的生命周期" class="sidebar-link">将要废弃的生命周期</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#componentwillreceiveprops" class="sidebar-link">componentWillReceiveProps</a></li><li class="sidebar-sub-header"><a href="/blog/react理解/生命周期详解.html#componentwillmount" class="sidebar-link">componentWillMount</a></li></ul></li></ul></li><li><a href="/blog/react理解/react整体更新流程.html" class="sidebar-link">react整体更新的流程</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>总结记录</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>数据结构算法</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="生命周期详解"><a href="#生命周期详解" aria-hidden="true" class="header-anchor">#</a> 生命周期详解</h1> <p><strong>生命周期</strong>，是 <code>ClassComponent</code> 独具的特性，<code>ClassComponent</code> 在 <code>react</code> 中的使用比重也很重，接下来，记录一下各个生命周期在源码中的调用过程。因为 <code>react</code> 的生命周期分为新老生命周期，所以先探讨新老都会具有的生命周期，然后单独探讨新老生命周期中各自存在的。</p> <h2 id="_1、新老生命周期都存在的"><a href="#_1、新老生命周期都存在的" aria-hidden="true" class="header-anchor">#</a> 1、新老生命周期都存在的</h2> <h3 id="_1-1-constructor"><a href="#_1-1-constructor" aria-hidden="true" class="header-anchor">#</a> 1.1 constructor</h3> <p><code>constructor</code> 可以说是相当熟悉的了，用js的特性来讲，它是“类”的一个构造器，虽然实际上的js是并没“类”这个东西的，不过用传统的面向对象的思维去看带，它就是类的一个构造器。既然是类的一个构造器，那么毫无疑问，肯定是在初始化的时候被调用的。</p> <p>问题在于，react是怎么察觉，当前这个类是否第一次被初始化？那么首先就要说到 react的<strong>虚拟dom</strong>，<strong>Fiber</strong> 了，这里并不会讲 <strong>Fiber</strong> 的一个概念，只需要知道，<strong>Fiber上有一个stateNode属性，指向ClassComponent的实例</strong>。如果是 <code>HostComponent</code>(真实的dom节点)，那么指向的就是挂载到浏览器界面的dom实例。当<strong>Fiber</strong> 对象是第一次创建的时候，这个 <code>stateNode</code> 属性是 <code>null</code>， <code>react</code> 就是根据这个属性去知晓，当前这个类是否初始化过。那么问题又来了，什么时候 <code>stateNode</code> 会是 <code>null</code> 呢？</p> <p>首先，在整个应用第一次渲染的时候，那时候是还没有构建 Fiber树的，那是个整个应用还以 <code>React.createElement</code> 一套一套的嵌套而成。在react从上到小不断的<strong>调和</strong>的过程中，才构建了与当前 <code>React.createElement</code> 结构所对应的 <strong>Fiber</strong> 树。<strong>Fiber</strong> 都是最新创建的所以 <code>stateNode</code> 也是为空的，所以在整个 <code>react</code> 应用第一次渲染的时候，<code>ClassComponent</code> 肯定也是第一次挂载，是会调用 <code>constructor</code> 的。</p> <p>还有一种情况就是，react第一次渲染已经完成，<strong>Fiber</strong> 树也已经被创建成功。其实要明白一点，<strong>Fiber</strong> 树是与 <code>React.createElement</code> 所生成的对象是对应的。</p> <div class="language-jsx extra-class"><pre class="language-jsx"><code><span class="token keyword">class</span> <span class="token class-name">ChildrenDemo</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'子'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">hello world</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Ceshi</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      hidden<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function-variable function">handClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prevState<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        hidden<span class="token punctuation">:</span> <span class="token operator">!</span>prevState<span class="token punctuation">.</span>hidden
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handClick<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">click!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
        </span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>hidden <span class="token operator">&amp;&amp;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ChildrenDemo</span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">}</span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>比如像上面这段代码，<code>&lt;ChildrenDemo /&gt;</code> 存在的条件在于 <code>hidden</code> 是否为true，那么第一次渲染的时候 <code>hidden</code> 为true，<code>&lt;ChildrenDemo /&gt;</code> 的Fiber对象也是被重新创建的，stateNode为null，那么实例是新创建的 <code>constructor</code> 也会被调用到，点一下click，<code>hidden</code> 属性被置为false了，<code>react.createElement</code> 所创建的 对象中没有这个节点了，实际上Fiber树中也会删除掉这个节点。那么在一次点click，<code>&lt;ChildrenDemo /&gt;</code> 又存在了，那么Fiber对象也会重新创建，stateNode为null，所以又要初始化实例。</p> <p>总结一句话就是：<strong>constructor</strong> 在组件实例初始化的时候调用。而且父组件的 <code>constructor</code> 比 子组件的先执行，因为调和是一个从上到下的过程，只有父组件先实例化，才能拿到render返回的值，才能在进行子组件的实例化。</p> <h3 id="_1-2-componentdidmount"><a href="#_1-2-componentdidmount" aria-hidden="true" class="header-anchor">#</a> 1.2 componentDidMount</h3> <p>这个生命周期对于 react 的用户来说，真的是熟悉的不能在熟悉了。这个生命周期调用的时机是组件第一次被挂载，并且是在所有dom节点都已经被挂载之后才会被调用。这个生命周期在源码中执行的时机是在Fiber树已经更新完成后，commitRoot中去执行。</p> <p>在 <code>commitRoot</code> 中，有专门的调用 <code>commitAllLifeCycles</code> 方法去执行不同类型的组件的操作。</p> <p>要理解这个操作是怎么左的，首先要知道，react在更新Fiber的过程中其实会维护一个链表，这个在Fiber对象中对应着一下几个属性：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 用来记录Side Effect</span>
  effectTag<span class="token punctuation">:</span> SideEffectTag<span class="token punctuation">,</span>
<span class="token comment">// 单链表用来快速查找下一个side effect</span>
  nextEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 子树中第一个side effect</span>
  firstEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 子树中最后一个side effect</span>
  lastEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
</code></pre></div><p><code>effect</code> 意义是副作用，react如何知道某个节点到底是要更新、删除、还是插入呢？其实就是凭借着 <code>effectTag</code> 这个属性。有对应的副作用就会给 <code>effectTag</code> 打上响应的值，并且将这个Fiber节点添加到链表中。这是很重要的一步操作，react在更新Fiber树的时候，从上往下更新，从下往上、从左至右的去提交更新。在 <code>completeUnitOfWork</code> 也就是提交节点更新的过程中有两段涉及到操作这个链表的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Append all the effects of the subtree and this fiber onto the effect</span>
        <span class="token comment">// list of the parent. The completion order of the children affects the</span>
        <span class="token comment">// side-effect order.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">.</span>firstEffect <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          returnFiber<span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>firstEffect<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgress<span class="token punctuation">.</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>firstEffect<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>lastEffect<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

<span class="token keyword">const</span> effectTag <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>effectTag<span class="token punctuation">;</span>
        <span class="token comment">// Skip both NoWork and PerformedWork tags when creating the effect list.</span>
        <span class="token comment">// PerformedWork effect is read by React DevTools but shouldn't be committed.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>effectTag <span class="token operator">&gt;</span> PerformedWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            returnFiber<span class="token punctuation">.</span>lastEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            returnFiber<span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          returnFiber<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>这两段代码的意思就是，将当前Fiber节点的子树上的产生的 <code>effectTag</code> 链条添加到父节点的 <code>firstEffect</code> 和 <code>lastEffect</code> ，然后当前节点如果也有更新的话也添加到父节点的 <code>firstEffect</code> 和 <code>lastEffect</code> 中，这样一步一步提交到最顶层，所有的产生了更新的节点就串成了一个链条存在最顶层的Fiber节点的 <code>firstEffect</code>  和 <code>lastEffect</code> 中，<code>firstEffect</code>  指向第一个，而<code>lastEffect</code> 指向最后一个，并且由于 <code>componentUnitOfWork</code>是自下而上，自左而又的，所以对于产生更新的节点的存储，同一层级中之前的是排于之后的前面，子节点排于父节点的前面，所以，可以断言，<code>componentDidMount</code> 生命周期，同一层级的节点中，写在前面的先执行，子节点比父节点先执行。并且观看源码，可以发现 <code>commitAllLifeCycles</code>  的操作是在 <code>commitAllHostEffects</code> 之后进行的，也就是dom节点的操作已经结束之后，所以这是为什么在 <code>componentDidMount</code>  中可以拿到dom实例的原因。顺便提一句，ref属性也是在这个时候被挂载上的。</p> <h3 id="_1-3-componentdidupdate"><a href="#_1-3-componentdidupdate" aria-hidden="true" class="header-anchor">#</a> 1.3 componentDidUpdate</h3> <p><code>componentDidUpdate</code> 其实在代码中与 <code>componentDidMount</code> 是在同一处被调用的。代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">startPhaseTimer</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> <span class="token string">'componentDidMount'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          instance<span class="token punctuation">.</span>props <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
          instance<span class="token punctuation">.</span>state <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
          instance<span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">stopPhaseTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">const</span> prevProps <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
          <span class="token keyword">const</span> prevState <span class="token operator">=</span> current<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
          <span class="token function">startPhaseTimer</span><span class="token punctuation">(</span>finishedWork<span class="token punctuation">,</span> <span class="token string">'componentDidUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          instance<span class="token punctuation">.</span>props <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
          instance<span class="token punctuation">.</span>state <span class="token operator">=</span> finishedWork<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>
          instance<span class="token punctuation">.</span><span class="token function">componentDidUpdate</span><span class="token punctuation">(</span>
            prevProps<span class="token punctuation">,</span>
            prevState<span class="token punctuation">,</span>
            instance<span class="token punctuation">.</span>__reactInternalSnapshotBeforeUpdate<span class="token punctuation">,</span>
          <span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">stopPhaseTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>可以看到，判断了一个 <code>current</code> 的变量，那么这个 <code>current</code> 是什么呢？其实react存在一个工作区的概念，就是在操作的时候所有的操作都是在工作区中进行，当操作完成之后再把以前的老的替换成这个工作区，下一次更新又会创建一个工作区。在Fiber对象的属性中有一个 <code>alternate</code> 属性指向的就是当前工作区的原本的Fiber节点。什么情况下 <code>current</code> 会为空呢？当节点是第一次渲染的时候，以前没有current就为空，当节点之前已经渲染过了，current指向的就是上一次渲染的Fiber节点。所以这里已经很清晰了，当节点是第一次渲染的时候调用 <code>componentDidMount</code>  不是第一次渲染也就是节点更新的时候调用 <code>componentDidUpdate</code> 并且传入了上一次渲染时候的props和state。所以，<code>componentDidUpdate</code> 生命周期也是，同一层级的节点中，写在前面的先执行，子节点比父节点先执行。所以最好不要在 <code>componentDidUpdate</code>  中调用 <code>setState</code> ，因为应用一旦更新又会触发这个生命周期方法，这个方法又去执行 <code>setState</code>  就会一直处于这个工程中。</p> <h3 id="_1-4-shouldcomponentupdate"><a href="#_1-4-shouldcomponentupdate" aria-hidden="true" class="header-anchor">#</a> 1.4 shouldComponentUpdate</h3> <p>这个生命周期优化react应用很重要的一次生命周期方法，可以用它来控制节点这次是否要更新，即使我们触发了 <code>setState</code> 。这个生命周期在 <code>beginWord</code> 也就是更新Fiber节点的时候被调用。在 <code>beginWord</code> 更新 <code>classComponent</code> 的过程中，会调用到 <code>checkShouldComponentUpdate</code> 这个方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
  workInProgress<span class="token punctuation">,</span>
  ctor<span class="token punctuation">,</span>
  oldProps<span class="token punctuation">,</span>
  newProps<span class="token punctuation">,</span>
  oldState<span class="token punctuation">,</span>
  newState<span class="token punctuation">,</span>
  nextContext<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">startPhaseTimer</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">,</span> <span class="token string">'shouldComponentUpdate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
      newProps<span class="token punctuation">,</span>
      newState<span class="token punctuation">,</span>
      nextContext<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">stopPhaseTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果当前的<code>classComponent</code> 实例中有设置  <code>shouldComponentUpdate</code> 方法的话，就返回这个方法返回的值，在这里也可以看到 <code>PureReactComponent</code> 的实现原理，如果当前 <code>classComponent</code> 是一个 <code>PureComponent</code> 就会浅比较新老props和新老state，就不说具体是怎么比较的了，反正只是做了一层浅了比较。如果两个对象完全相同则不更新，一般情况下也不会出现两个对象完全相同的情况。大多情况下都会比较第一层的属性。如果新对象比老对象多一个属性或者少一个属性，肯定是符合更新要求的。如果是 <code>a={value: 1}</code> <code>b={value: 1}</code> 这种，那么实际上对象中的属性是完全一直的也不会更新。如果是 <code>a={obj:{}}</code> <code>b={obj:{}}</code> 这种，我们都知道对象是不等于一个对象的，即使他们都是 <code>{}</code> ，这种情况下不会在往下去比较a.obj和b.obj的值，视为符合更新条件。</p> <p>很明显可以看到，如果props和state都没有改变的话，就返回false。如果即没有 <code>shouldComponentUpdate</code> 也没有 <code>PureComponent</code>  那就直接返回了一个true，说明在一般情况下，普通 <code>Component</code> 每次父组件更新，子组件也会更新。</p> <h3 id="_1-5-componentwillunmount"><a href="#_1-5-componentwillunmount" aria-hidden="true" class="header-anchor">#</a> 1.5 componentWillUnMount</h3> <p>这也是很熟悉的一个生命周期属性，组件即将被卸载的时候调用。这个生命周期也是在 <code>commitRoot</code> 阶段被调用，在之前说的 <code>commitAllHostEffects</code>  操作中，如果Fiber对象的 <code>effectTap</code> 被打上了 <code>Deletion</code> 也就是删除。就会进入删除节点的逻辑中，<code>componentWillUnMount</code> 也是在这其中被调用。</p> <p>当一个节点被删除的时候，其子节点也会被删除。通过看源码，它这个遍历过程也是跟之前更新节点的时候的过程是一样的 。先沿着 Fiber.child 一直找一侧，往下找之前如果是 <code>classComponent</code> 并且有设置这个方法就先调用。当Fiber.child找到最末尾的时候，就开始找兄弟节点。所以 这个执行的顺序应该是，父节点先执行 <code>componentWillUnMount</code> 然后是沿着fiber树找 Fiber.child 也就是第一个子节点，然后从下往上找兄弟节点。卸载ref属性也是在这个过程中进行的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Child1 <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>Child3 <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

<span class="token comment">// Child1</span>
<span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Child2 <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>比如说一个组件的render是这样，当前组件的 <code>componentWillUnMount</code> 最先执行，然后是 <code>Child1</code>，然后是 <code>Child2</code> 最后是 <code>Child3</code>。</p> <h2 id="_2新生命周期"><a href="#_2新生命周期" aria-hidden="true" class="header-anchor">#</a> 2新生命周期</h2> <h3 id="_2-1-getsnapshotbeforeupdate"><a href="#_2-1-getsnapshotbeforeupdate" aria-hidden="true" class="header-anchor">#</a> 2.1 getSnapshotBeforeUpdate</h3> <p>这个生命周期可能使用的比较少，它的作用就是获取更新前的一个快照，在最近一次渲染输出中被调用。
首先是在 <code>beginWork</code> 的时候，如果设置了这个生命周期，就会给节点的 <code>effctTag</code> 加上 <code>Snapshot</code> ，然后到了<code>commitWork</code> 阶段，也是会遍历 effctTag 链条。然后在提交到 DOM 节点 之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate。</p> <h3 id="_2-2-getderivedstatefromprops"><a href="#_2-2-getderivedstatefromprops" aria-hidden="true" class="header-anchor">#</a> 2.2 getDerivedStateFromProps</h3> <p>这个生命周期在组件第一次挂或组件发生更新的时候都会被触发。在使用的时候只能作为组件的静态方法使用，也就是是说，在这个生命周期中不能访问 <code>this</code> ，不能通过 <code>this.setState</code> 去设置 <code>state</code> 而是返回一个对象用于设置 <code>state</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">getDerivedStateFromProps</span><span class="token punctuation">(</span>nextProps<span class="token punctuation">,</span> prevState<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>在我的理解中这个生命周期是对标废弃的生命周期 <code>componentWillReceiveProps</code>(将要废弃) 的，不同的是，<code>componentWillReceiveProps</code> 只在组件的更新流程中且<code>props</code>发生改变时才会被调用，而 <code>getDerivedStateFromProps</code> 无论是组件加载还是更新都会调用。<code>componentWillReceiveProps</code> 可以访问到 <code>this</code>，可以通过 <code>this.setState</code> 来设置 <code>state</code> 的值。 而 <code>getDerivedStateFromProps</code> 只是返回了一个对象。</p> <h2 id="将要废弃的生命周期"><a href="#将要废弃的生命周期" aria-hidden="true" class="header-anchor">#</a> 将要废弃的生命周期</h2> <h3 id="componentwillreceiveprops"><a href="#componentwillreceiveprops" aria-hidden="true" class="header-anchor">#</a> componentWillReceiveProps</h3> <p><code>componentWillReceiveProps</code> 是将要被废弃的生命周期。 看着意思是当组件的 <code>props</code> 发生变化时触发的使命周期，但是在实际使用中你会发现，这个触发的时机严格来讲应该是父组件重新render的时候(父组件重新render势必会引发props的改变)。所以使用这个生命周期的时候有时候是会造成死循环的，比如，在 <code>componentWillReceiveProps</code> 里执行了会导致父组件发生更新重新render的情况。我认为这是这个生命周期即将被废弃的其中一个原因。</p> <p>然而这个生命周期被废弃的更重要的一个原因，应该是，在 <code>componentWillReceiveProps</code> 中是可以进行 <code>setState</code> 操作的，而现在react16的源码中，使用 <code>setState</code> 就会为每个 <code>Fiber</code> 对象创建一个有关于优先级的标志、而在 <code>componentWillReceiveProps</code> 中执行的 <code>setState</code> 由于本次更新还没有结束，在进入 <code>requestWork</code> 的时候就会被大打断，所以react在现在还没有完全废弃掉 <code>componentWillReceiveProps</code> 生命周期的时候，在组件更新的代码中 触发完 <code>componentWillReceiveProps</code> 生命周期后执行了 <code>processUpdateQueue</code> 即重新处理 <code>Fiber</code> 对象的 <code>UpdateQueue</code> ，目的就是立即执行 <code>componentWillReceiveProps</code> 的 <code>setState</code> 添加到 Fiber对象的 <code>UpdateQueue</code> 中操作。 所以react现在修改了代码，使得<code>classComponent</code>在***更新***的过程中不能在“合理”的使用 <code>setState</code>。</p> <p>为什么用“合理”这两个字？在 <code>classComponent</code> 的render方法中，你也可以使用 <code>setState</code> 方法，但是这样换来的是死循环。所以这是不合理的，而在 <code>componentWillReceiveProps</code> 使用 <code>setState</code> 只要不触发父组件的更新，就不会引发死循环，但这看起来似乎不可控制，因为没人能保证开发者永远写出正确的代码。</p> <h3 id="componentwillmount"><a href="#componentwillmount" aria-hidden="true" class="header-anchor">#</a> componentWillMount</h3> <p>这个生命周期在组件是第一次加载，真正挂在到dom树上之前调用。它废弃的原因与 <code>componentWillReceiveProps</code> 相同，也是因为可以在其中进行 <code>setState</code> 的操作。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.7b18d2f0.js" defer></script><script src="/assets/js/13.b2bd6144.js" defer></script>
  </body>
</html>
