(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{196:function(t,_,v){"use strict";v.r(_);var e=v(0),a=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"tcp、http、udp记录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp、http、udp记录","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP、http、udp记录")]),t._v(" "),v("h2",{attrs:{id:"_1-tcp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-tcp协议","aria-hidden":"true"}},[t._v("#")]),t._v(" 1 TCP协议")]),t._v(" "),v("p",[t._v("简介：传输控制"),v("em",[t._v("协议")]),t._v("（"),v("em",[t._v("TCP")]),t._v("，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信"),v("em",[t._v("协议")]),t._v("。处于网络五层模型（应用层、传输层、网络层、数据链路层、物理层）中的传输层。")]),t._v(" "),v("h2",{attrs:{id:"_1-1tcp-的三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-1tcp-的三次握手","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.1TCP 的三次握手")]),t._v(" "),v("p",[t._v("首先要明白的是，"),v("code",[t._v("TCP")]),t._v(" 连接一定是由一方主动发起的。为什么要握手三次呢？ 想象这样一个场景，甲军和乙军是友军，甲军在前线战斗遇到的敌人很是顽抗，甲军决定请求乙军支援导弹轰炸敌军，但是敌军离自己很近，贸然轰炸的话会伤到自己。那么如果甲军要正确的轰炸敌军，首先要做的第一件事情就是发送消息给乙军，请求轰炸自己所在的地方，发送这条消息后甲军也不能直接就撤离， 因为乙军很有可能并没有收到消息，如果贸然撤离那就是将阵地拱手送给敌人，所以甲军继续在原地等待；乙军接收到甲军发送的请求轰炸的消息过后，肯定也不能直接就轰炸了，他肯定要通知甲军撤离，等到甲军撤离之后才能开始轰炸，然后乙军又发送一条消息告诉甲军，消息乙收到，你们赶快撤离吧。然后甲军收到乙军回复的消息，撤离阵地并发送消息告诉甲军，已经撤离，才能开始轰炸战场。")]),t._v(" "),v("p",[v("code",[t._v("TCP")]),t._v(" 的连接也与此一样，连接是针对双方的，所以两次客户端发送消息到服务端、服务端响应客户端消息这两次握手肯定是必不可少，为什么还要进行第三次握手呢？第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。譬如发起请求遇到类似这样的情况：客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。如果握手只有两次的话 ，那么到这里，连接就建立了，但是此时客户端并没有任何数据要发送，而服务端还在傻傻的等候佳音，造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。")]),t._v(" "),v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://s1.ax1x.com/2020/06/10/t7wCOx.png"}}),t._v(" "),v("ol",[v("li",[t._v("首先是客户端主动像服务端发送一段报文，其中，标志位为"),v("strong",[t._v("SYN")]),t._v("，表示"),v("strong",[t._v("请求建立新连接")]),t._v("，然后设置序号seq为x。然后客户端进入 "),v("strong",[t._v("SYN-SENT")]),t._v(" 阶段。")]),t._v(" "),v("li",[t._v("服务端接收到来此客户端的报文后，给客户端返回一段报文，标志位为 "),v("strong",[t._v("SYN")]),t._v(" 和 "),v("strong",[t._v("ACK")]),t._v(" ，设置序号为 seq = y ，确认号为 ack = x + 1 （x是客户端传过来的seq），然后服务端进入 "),v("strong",[t._v("SYN-RCVD")]),t._v(" 阶段。")]),t._v(" "),v("li",[t._v("客户端收到服务端的响应消息后在回复报文，标志位为 "),v("strong",[t._v("ACK")]),t._v("，seq=x+1, ack = y+1。然后，TCP连接就可以成功的建立了。")])]),t._v(" "),v("h2",{attrs:{id:"_1-2-四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.2 四次挥手")]),t._v(" "),v("p",[t._v("三次握手对应着TCP连接的建立，而四次挥手则对应这TCP连接的关闭。")]),t._v(" "),v("p",[t._v("关闭连接肯定也是由一方主动发起的。假设是由客户端发起的，用大白话来描述这个事情就是：我客户端想要关闭TCP连接了，你有什么消息还没发完赶快发吧，然后服务端收到了客户端的消息，回复到：好的，请求我收到了，让我准备准备，继续等我的消息。然后客户端就进入了 "),v("strong",[t._v("FIN-WAIT")]),t._v(" 阶段。服务端准备好了之后发消息告诉客户端：好了，我准备好了。客户端收到消息之后，知道可以关闭连接了，回复服务端：好，我们开始关闭把。但是还是不相信网络，服务端收到了回复消息之后就把连接关闭掉了，客户端还会继续等待 2MSL 事件，在这期间依然没有收到服务端的消息就会把连接关闭掉。")]),t._v(" "),v("p",[t._v("关闭连接的请求不一定只能由客户端发送，记住，那方先主动请求关闭哪方就最后关闭。")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://s1.ax1x.com/2020/06/10/t7doSs.png",alt:""}})]),t._v(" "),v("ol",[v("li",[t._v("A向B发送终止报文，标志位为FIN，seq为u")]),t._v(" "),v("li",[t._v("B收到A的终止报文后，响应，标志位为ACK，seq=v， ack=u+1")]),t._v(" "),v("li",[t._v("B向A发送终止报文，标志位为FIN、ACK，seq=w，ack=u+1")]),t._v(" "),v("li",[t._v("A收到B的终止报文响应，标志位为ACK seq=u+1，ack=w+1，B收到此报文后断开连接 ，A在等待2MSL事件都没有收到B的消息就断开。")])]),t._v(" "),v("h2",{attrs:{id:"_2、http-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、http-协议","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、HTTP 协议")]),t._v(" "),v("p",[v("code",[t._v("http")]),t._v(" 是位于传输层的协议，在 "),v("code",[t._v("TCP")]),t._v(" 连接的基础上进行。")]),t._v(" "),v("h3",{attrs:{id:"_2-1-http-1-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-http-1-0","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.1 http/1.0")]),t._v(" "),v("p",[t._v("我们都知道，"),v("code",[t._v("http")]),t._v(" 是基于 "),v("code",[t._v("TCP连接")]),t._v("进行传输的，在http/1.0中，每个 "),v("code",[t._v("http")]),t._v(" 响应完成之后都会断开 "),v("code",[t._v("TCP")]),t._v(" 连接，下一个 "),v("code",[t._v("http")]),t._v(" 请求又会重新的去建立 "),v("code",[t._v("TCP")]),t._v(" 连接，代价过大，就像是很多人结婚得买房把？，http/1.0就是每结一次婚就买一套房，离婚了就把房子砸了，下次结婚再买一套。")]),t._v(" "),v("h3",{attrs:{id:"_2-2-http-1-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-http-1-1","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.2 http/1.1")]),t._v(" "),v("p",[t._v("随着网页的越来越普及，页面中渐渐从的出现了大量诸如图片的静态资源请求，这时候每每请求一张图片就要创建一次 "),v("code",[t._v("TCP")]),t._v(" 连接请求成功之后在关闭掉显的太浪费了。"),v("strong",[t._v("http/1.1")]),t._v(" 新增了一个叫做 "),v("code",[t._v("Connection")]),t._v(" 的头，当值为 "),v("code",[t._v("keep-alive")]),t._v(" 的时候，"),v("code",[t._v("TCP")]),t._v(" 连接并不会立即断开，下一个 "),v("code",[t._v("http")]),t._v(" 请求可以再次基于这个 "),v("code",[t._v("TCP")]),t._v(" 连接进行传输，除非写明了 "),v("code",[t._v("Connection")]),t._v(" 为 "),v("code",[t._v("close")]),t._v("。这就省去了一大部分建立和断开 "),v("code",[t._v("TCP")]),t._v(" 连接的操作。")]),t._v(" "),v("p",[t._v("但是 http/1.1 还是存在问题，单个 "),v("code",[t._v("TCP")]),t._v(" 连接同一时间只能解决一个问题，就像是好男人同一时间只能谈一个女朋友，想要谈下一个女朋友你得先和目前的这个分手。如果进入一个页面的时候针对同一个域名同时有几个请求怎么办？浏览器为了提高加载效率的做法是同时和服务器建立多个 "),v("code",[t._v("TCP")]),t._v(" 连接，但是也是有限制的，比如Chrome 浏览器就规定了对于同一个 "),v("code",[t._v("HOST")]),t._v(" 最多只能同时建立 6个 "),v("code",[t._v("TCP")]),t._v(" 连接，不同的浏览器之间有区别。那对于进入一个同时有多个请求都在同一个域名下，那么浏览器就会与这个HOST的服务器建立多个 "),v("code",[t._v("TCP")]),t._v(" 连接，具体建立多少个取决于浏览器，比如20张图片，chrome浏览器建立了6个TCP连接，那么有6张图片就能在同一时间内进行下载，剩下的，不好意思先排队，等前面的"),v("code",[t._v("http")]),t._v(" 请求结束了才能开始下一个。就像是你的女神已经有男朋友了，你只能等到女神和她男朋友分手了才有机会和她在一起，区别在于，http请求总会结束，而你的女神，很多时候并不会和她男朋友分手～")]),t._v(" "),v("p",[t._v("http/1.1 相对于 http1.0的区别不只在于保持 "),v("code",[t._v("TCP")]),t._v(" 连接的持久性，缓存方面也增加了更多的缓存策略，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。")]),t._v(" "),v("h3",{attrs:{id:"_2-3-http-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-http-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.3 http/2")]),t._v(" "),v("p",[t._v("尽管 http/1.1 针对 http/1.0 做了优化，但是还是无法解决对头阻塞的问题，也就是同一时间内只能处理一个请求，如果浏览器的 所建立的 "),v("code",[t._v("TCP")]),t._v(" 连接达到了上限，那么就会出现后加载的资源排队等着先加载的资源响应之后才能开始加载。")]),t._v(" "),v("p",[t._v("http/2 就解决了这个问题，相比http/1.x，它的新特性有：")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("新的二进制格式")]),t._v("（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。")]),t._v(" "),v("li",[v("strong",[t._v("多路复用")]),t._v("（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。")]),t._v(" "),v("li",[v("strong",[t._v("Header压缩")]),t._v("，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。")])]),t._v(" "),v("p",[t._v("我认为其中最大的亮点在于第二点，http2支持了并行处理请求，这样当同时加载了同一个域名下的几个资源的时候，如果前面的资源较大也不用耗费时间去等待了，大家并行加载，互不影响，对于同一个域名下有多个请求也不用去建立多个TCP连接了，这样网页性能将会有大大的提升。")]),t._v(" "),v("h2",{attrs:{id:"_3-udp协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-udp协议","aria-hidden":"true"}},[t._v("#")]),t._v(" 3 UDP协议")]),t._v(" "),v("p",[t._v("UDP和TCP一样是工作在传输层的协议，与TCP不同的是，它是一种无连接的协议。UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法，与TCP相比它的传输也不可靠，不提供可靠性。但是传输速度比TCP要快，HTTP协议不急于UDP的原因就是HTTP协议对数据准确性的要求高。")]),t._v(" "),v("p",[t._v("基于UDP协议的特性，它更适用一些对数据准确性要求和丢包要求较低，但是速度要求高的场景，比如即使通讯、网络语音通话等。")]),t._v(" "),v("h2",{attrs:{id:"_4-cdn"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-cdn","aria-hidden":"true"}},[t._v("#")]),t._v(" 4 cdn")]),t._v(" "),v("p",[t._v("文章：https://blog.csdn.net/lihao21/article/details/52808747")])])}],!1,null,null,null);_.default=a.exports}}]);