(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{215:function(t,_,v){"use strict";v.r(_);var e=v(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"贪心算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 贪心算法")]),t._v(" "),v("p",[t._v("今天下午，有点闲所以针对标签 "),v("em",[t._v("贪心算法")]),t._v(" 刷了几道题，趁着现在有点感觉，所以记录一下今天下午刷题的感悟。")]),t._v(" "),v("p",[t._v("贪心算法给人的感觉是与动态规划特别类似的，不同于回朔算法具有固定的套式，我认为它们更加强调的是一种解题的思想，即从局部最优解推导出全局最优解。")]),t._v(" "),v("p",[t._v("在贪心算法中，当前步的最优解是由上一步的最优解推算得出的，而上一步之前的最优解则不做保留。"),v("strong",[t._v("贪心算法中，每一步的最优解一定包含上一步的最优解。")])]),t._v(" "),v("p",[v("strong",[t._v("而对于动态规划算法来说，全局最优解中一定包含着某一个局部的最优解")]),t._v("，但不一定包含前一个最优解，所以很多时候动态规划需要记录所有的子状态。动态规划最关键的地方在于状态转移方程的推导，即如何根据初始状态推导出局部最优解，然后根据局部最优解在推出全局最优解。这个状态转移方程的推导过程，其中滋味可谓是妙不可言，容易令人上头。。")]),t._v(" "),v("p",[t._v("贪心算法和动态规划都属于递推算法中的一种，需要注意的是，贪心算法最后得到的解并不一定是最优解，而是一个比较好的解。对比起来，动态规划就好像是纵观全局；而贪心算法像是及时行乐，它不管以后，只管当前最优。")]),t._v(" "),v("p",[t._v("举个例子，现在要凑足 15 元钱，有面值 11 元、5 元和 1 元的钱，如何花费最少的张数去凑足 15 元？")]),t._v(" "),v("ul",[v("li",[t._v("动态规划：使用动态对话可以得出最优的解为 3 张 5 元面值的")]),t._v(" "),v("li",[t._v("贪心算法：贪心算法，最终要的在一个贪字。即我要凑够 15 元，我首先就去挑选一张面额最大的钱，然后看还差多少钱，然后根据还差多少钱去挑选能选到的最大面额的钱。这样去思考得到的近似最优解为：1 张 11元的和 4 张 1元的。")])]),t._v(" "),v("p",[t._v("接下来附上几道简单的运用贪心算法的题目的思考和解题过程。")])])}],!1,null,null,null);_.default=n.exports}}]);