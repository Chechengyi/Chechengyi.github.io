(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{191:function(t,e,s){"use strict";s.r(e);var r=s(0),a=Object(r.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),s("p",[t._v("在掘金潜水的时间长达一年之后，我终于鼓起勇气开始写我的第一篇文章了。前端小菜，只是想记录一下自己的想法，望各位看到这文的大佬轻喷。")]),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),s("p",[t._v("先厚脸皮的介绍一下我的项目， "),s("strong",[t._v("sweet-storage")]),t._v(",  请无视这土的要死的名字。\ngithub的地址为："),s("a",{attrs:{href:"https://github.com/Chechengyi/sweet-storage",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Chechengyi/sweet-storage"),s("OutboundLink")],1),t._v("。 顺便也正（卑）大（鄙）光（无）明（耻）的求一波star。\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/17/16a2b15609f36072?w=640&h=640&f=jpeg&s=22824",alt:""}})]),t._v(" "),t._m(6),t._v(" "),s("p",[t._v("咳咳咳！ 废话不多说了，讲一下我的实现思路。")]),t._v(" "),t._m(7),t._v(" "),t._m(8),t._m(9),t._v(" "),s("p",[t._v("但是这里也有一个问题，就是。可能我们需要有过期时间存储的时间不只有一条啊。难道存了三条我就做三个定时器？存的100条我就做100个定时器？ 这也太low了而且也并不符合实际。于是我冥思苦想，发现我前几天刚学习的优先队列很适合用在这里。")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),s("p",[s("strong",[t._v("sweet-storage")]),t._v(" 实现的大概思路就说完了，有兴趣的同学可以去看看源码实现，在此强调 github的地址为："),s("a",{attrs:{href:"https://github.com/Chechengyi/sweet-storage",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Chechengyi/sweet-storage"),s("OutboundLink")],1),t._v("。   我的代码写的很通（垃）俗易（圾）懂。")]),t._v(" "),t._m(13),t._v(" "),s("p",[t._v("如果有不对的地方希望朋友们指出，希望朋友们多给我提建议")]),t._v(" "),s("p",[t._v("最后在强调一波！！！")]),t._v(" "),s("p",[t._v("github的地址为："),s("a",{attrs:{href:"https://github.com/Chechengyi/sweet-storage",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/Chechengyi/sweet-storage"),s("OutboundLink")],1),t._v("。")]),t._v(" "),s("p",[t._v("求star 求fuck......")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"给localstorage加上过期时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#给localstorage加上过期时间","aria-hidden":"true"}},[this._v("#")]),this._v(" 给localStorage加上过期时间")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"一、酷酷的开头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、酷酷的开头","aria-hidden":"true"}},[this._v("#")]),this._v(" 一、酷酷的开头")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在现在前后端分离的开发模式下，存储信息一般都不在使用以往使用的cookie了，就拿笔主我之前做过的项目来说。我们都是登录成功了之后后端会返回给我一个token，一般情况下我会将这个token存到"),e("code",[this._v("localStorage")]),this._v("中，后续再每一次请求中都会将这个token携带在请求头中。 至于为什么要存到"),e("code",[this._v("localStorage")]),this._v("中呢，相信做过单页web应用的开发者们也知道，如果不存着，那用户刷新了就啥都没有了。")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("可以见得前端存储在项目中是越来越重要了，浏览器给我们提供了两个存储方案，一个是"),s("code",[t._v("localStorage")]),t._v("，一个是"),s("code",[t._v("sessionStorage")]),t._v("。 存到"),s("code",[t._v("localStorage")]),t._v("中的信息是永久存储,如果用户不手动删除或者代码中没有"),s("code",[t._v("localStorage.removeItem(xxx)")]),t._v("这样的调用那这个信息将永远不会消失; 在"),s("code",[t._v("sessionStorage")]),t._v("中存储的信息则是一次性的，用户关掉网页了下一次在进入这个网页信息就不会再存储了。 但是在实际项目的运用中，这两个方案的表现都不是那么令人满意。就比如说，我想要实现用户登录之后七天之内不需要再次登录这样的功能，token生成了之后，后端设置了这个token的过期时间为7天，ok，传到前端， 但是针对浏览器目前提供的存储方案，我却只能选择永久存储和一次性存储。一次性存储肯定是不能满足需求的，永久存储也违背了我的意愿。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"二、之前在项目中的解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、之前在项目中的解决方案","aria-hidden":"true"}},[this._v("#")]),this._v(" 二、之前在项目中的解决方案")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("之前我在项目中的做法是，在用"),e("code",[this._v("localStorage")]),this._v("存储了token值的同时， 我还存了一个过期时间（一个毫秒数），然后在项目初始化的时候我就会去检查这个时间看看是不是已经小于当前时间了，如果是就将token删掉。 这样后续项目在使用到这个token的时候token就已经从"),e("code",[this._v("localStorage")]),this._v("中被删掉了。但是这样做也有一个问题，如果打开项目的时间刚好是还有10s token就过期的话，token也不会被删掉了。于是我脑袋里就在构想一个可（垃）靠（圾）的解决方案，一不做，二不休，我把它封装成了一个工具。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"三、提出新的想法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、提出新的想法","aria-hidden":"true"}},[this._v("#")]),this._v(" 三、提出新的想法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在遇到有过期时间的存储需求时， 用我这个项目举栗子， "),e("code",[this._v("storage.save('name', 'chechengyi', 10000)")]),this._v("  这行代码的意思是我想在"),e("code",[this._v("localStorage")]),this._v("中存一个键为name，值为chechengyi的信息，我希望这条信息只存10s，在将信息存入localStorage中的同时，我会把它的过期时间信息以")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[this._v("  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[this._v("{")]),this._v("\n      key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[this._v(":")]),this._v(" time\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[this._v("}")]),this._v("\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("的形式也存到localStorage中。 key就是键， time就是这条信息到期的时间。 这里的时间的话应该存的是"),s("code",[t._v("new Date().getTime()")]),t._v("+我们设置的时间。这样就得到了一个精确的毫秒数了。  这个过期时间信息在我的项目中以"),s("code",[t._v("ISTORAGE_RECORD")]),t._v("的字段存储。 然后后面我们在根据这里面所提取出来的时间，即："),s("code",[t._v("new Date().getTime()-time")]),t._v("这个时间去做一个定时器。定时器时间到了就将"),s("code",[t._v("localStorage")]),t._v("中存的信息以及存的时间信息就是那个对象中的key-time删掉就行了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("我们可以这样做，基于"),e("code",[this._v("ISTORAGE_RECORD")]),this._v("拿出来的对象里的time去做一个最小堆（我的这个优先队列是基于最小堆的），最小堆嘛，根节点肯定就是最小的，time最小的那个不就是最先执行的定时器吗？  等这个定时器执行时就删掉"),e("code",[this._v("localStorage")]),this._v("里存的信息和时间信息，然后优先队列出列，下一个排队等着出列的元素就是下一个时间最近，等着过期的信息了。这里涉及到了最小堆数据结构的操作就不多讲了。有兴趣的同学可以自己去看看实现。这就是我的项目实现的大概思路， 真正实现的话还要去考虑还没过期就被用户删除了等等的情况。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("到这里了我又在想，不行啊，这样过期了也只是“悄悄”的过期了。 我想知道它什么时候过期的，也就是我希望它过期的时候能通知我一声行不行啊？ 于是经过我又一轮的冥思苦想，我发现我去年学的发布-订阅模式可以用到这里。然后就是代码实现啦，无非就是做了一个observers对象。 以存储的key名去订阅了一个事件，在我的项目中就是"),e("code",[this._v("storage.on('name', (key)=>{})")]),this._v(" 然后再定时器执行的时候我会"),e("code",[this._v("observers.trriger('name')")]),this._v("去发布这个事件，并且将需要被删除掉的信息的key传入订阅的函数当中。 这样就做到了通知的功能。具体发布-订阅模式怎么实现的也不在此多做赘述了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"四、无耻的总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、无耻的总结","aria-hidden":"true"}},[this._v("#")]),this._v(" 四、无耻的总结")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("我还将这个项目传到了npm上面， "),e("code",[this._v("npm install sweet-storage")]),this._v("就可以安装到本地。学以致用，这一年多来在各大论坛潜水每次看到别人分享心得心里都痒痒的，这次总算是下定了决心踏出第一步。在这个过程中也学习到了很多，希望自己能够坚持下去。")])}],!1,null,null,null);e.default=a.exports}}]);