(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{178:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"生命周期详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期详解","aria-hidden":"true"}},[t._v("#")]),t._v(" 生命周期详解")]),t._v(" "),a("p",[a("strong",[t._v("生命周期")]),t._v("，是 "),a("code",[t._v("ClassComponent")]),t._v(" 独具的特性，"),a("code",[t._v("ClassComponent")]),t._v(" 在 "),a("code",[t._v("react")]),t._v(" 中的使用比重也很重，接下来，记录一下各个生命周期在源码中的调用过程。因为 "),a("code",[t._v("react")]),t._v(" 的生命周期分为新老生命周期，所以先探讨新老都会具有的生命周期，然后单独探讨新老生命周期中各自存在的。")]),t._v(" "),a("h2",{attrs:{id:"_1、新老生命周期都存在的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、新老生命周期都存在的","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、新老生命周期都存在的")]),t._v(" "),a("h3",{attrs:{id:"_1-1-constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-constructor","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.1 constructor")]),t._v(" "),a("p",[a("code",[t._v("constructor")]),t._v(" 可以说是相当熟悉的了，用js的特性来讲，它是“类”的一个构造器，虽然实际上的js是并没“类”这个东西的，不过用传统的面向对象的思维去看带，它就是类的一个构造器。既然是类的一个构造器，那么毫无疑问，肯定是在初始化的时候被调用的。")]),t._v(" "),a("p",[t._v("问题在于，react是怎么察觉，当前这个类是否第一次被初始化？那么首先就要说到 react的"),a("strong",[t._v("虚拟dom")]),t._v("，"),a("strong",[t._v("Fiber")]),t._v(" 了，这里并不会讲 "),a("strong",[t._v("Fiber")]),t._v(" 的一个概念，只需要知道，"),a("strong",[t._v("Fiber上有一个stateNode属性，指向ClassComponent的实例")]),t._v("。如果是 "),a("code",[t._v("HostComponent")]),t._v("(真实的dom节点)，那么指向的就是挂载到浏览器界面的dom实例。当"),a("strong",[t._v("Fiber")]),t._v(" 对象是第一次创建的时候，这个 "),a("code",[t._v("stateNode")]),t._v(" 属性是 "),a("code",[t._v("null")]),t._v("， "),a("code",[t._v("react")]),t._v(" 就是根据这个属性去知晓，当前这个类是否初始化过。那么问题又来了，什么时候 "),a("code",[t._v("stateNode")]),t._v(" 会是 "),a("code",[t._v("null")]),t._v(" 呢？")]),t._v(" "),a("p",[t._v("首先，在整个应用第一次渲染的时候，那时候是还没有构建 Fiber树的，那是个整个应用还以 "),a("code",[t._v("React.createElement")]),t._v(" 一套一套的嵌套而成。在react从上到小不断的"),a("strong",[t._v("调和")]),t._v("的过程中，才构建了与当前 "),a("code",[t._v("React.createElement")]),t._v(" 结构所对应的 "),a("strong",[t._v("Fiber")]),t._v(" 树。"),a("strong",[t._v("Fiber")]),t._v(" 都是最新创建的所以 "),a("code",[t._v("stateNode")]),t._v(" 也是为空的，所以在整个 "),a("code",[t._v("react")]),t._v(" 应用第一次渲染的时候，"),a("code",[t._v("ClassComponent")]),t._v(" 肯定也是第一次挂载，是会调用 "),a("code",[t._v("constructor")]),t._v(" 的。")]),t._v(" "),a("p",[t._v("还有一种情况就是，react第一次渲染已经完成，"),a("strong",[t._v("Fiber")]),t._v(" 树也已经被创建成功。其实要明白一点，"),a("strong",[t._v("Fiber")]),t._v(" 树是与 "),a("code",[t._v("React.createElement")]),t._v(" 所生成的对象是对应的。")]),t._v(" "),a("div",{staticClass:"language-jsx extra-class"},[a("pre",{pre:!0,attrs:{class:"language-jsx"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ChildrenDemo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'子'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("hello world")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ceshi")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      hidden"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("handClick")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        hidden"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("prevState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hidden\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n        ")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("button")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("onClick")]),a("span",{pre:!0,attrs:{class:"token script language-javascript"}},[a("span",{pre:!0,attrs:{class:"token script-punctuation punctuation"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("handClick"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("click!")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("button")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n        ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hidden "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("ChildrenDemo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token plain-text"}},[t._v("\n      ")]),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("比如像上面这段代码，"),a("code",[t._v("<ChildrenDemo />")]),t._v(" 存在的条件在于 "),a("code",[t._v("hidden")]),t._v(" 是否为true，那么第一次渲染的时候 "),a("code",[t._v("hidden")]),t._v(" 为true，"),a("code",[t._v("<ChildrenDemo />")]),t._v(" 的Fiber对象也是被重新创建的，stateNode为null，那么实例是新创建的 "),a("code",[t._v("constructor")]),t._v(" 也会被调用到，点一下click，"),a("code",[t._v("hidden")]),t._v(" 属性被置为false了，"),a("code",[t._v("react.createElement")]),t._v(" 所创建的 对象中没有这个节点了，实际上Fiber树中也会删除掉这个节点。那么在一次点click，"),a("code",[t._v("<ChildrenDemo />")]),t._v(" 又存在了，那么Fiber对象也会重新创建，stateNode为null，所以又要初始化实例。")]),t._v(" "),a("p",[t._v("总结一句话就是："),a("strong",[t._v("constructor")]),t._v(" 在组件实例初始化的时候调用。而且父组件的 "),a("code",[t._v("constructor")]),t._v(" 比 子组件的先执行，因为调和是一个从上到下的过程，只有父组件先实例化，才能拿到render返回的值，才能在进行子组件的实例化。")]),t._v(" "),a("h3",{attrs:{id:"_1-2-componentdidmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-componentdidmount","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.2 componentDidMount")]),t._v(" "),a("p",[t._v("这个生命周期对于 react 的用户来说，真的是熟悉的不能在熟悉了。这个生命周期调用的时机是组件第一次被挂载，并且是在所有dom节点都已经被挂载之后才会被调用。这个生命周期在源码中执行的时机是在Fiber树已经更新完成后，commitRoot中去执行。")]),t._v(" "),a("p",[t._v("在 "),a("code",[t._v("commitRoot")]),t._v(" 中，有专门的调用 "),a("code",[t._v("commitAllLifeCycles")]),t._v(" 方法去执行不同类型的组件的操作。")]),t._v(" "),a("p",[t._v("要理解这个操作是怎么左的，首先要知道，react在更新Fiber的过程中其实会维护一个链表，这个在Fiber对象中对应着一下几个属性：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来记录Side Effect")]),t._v("\n  effectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" SideEffectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单链表用来快速查找下一个side effect")]),t._v("\n  nextEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中第一个side effect")]),t._v("\n  firstEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中最后一个side effect")]),t._v("\n  lastEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),a("p",[a("code",[t._v("effect")]),t._v(" 意义是副作用，react如何知道某个节点到底是要更新、删除、还是插入呢？其实就是凭借着 "),a("code",[t._v("effectTag")]),t._v(" 这个属性。有对应的副作用就会给 "),a("code",[t._v("effectTag")]),t._v(" 打上响应的值，并且将这个Fiber节点添加到链表中。这是很重要的一步操作，react在更新Fiber树的时候，从上往下更新，从下往上、从左至右的去提交更新。在 "),a("code",[t._v("completeUnitOfWork")]),t._v(" 也就是提交节点更新的过程中有两段涉及到操作这个链表的代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Append all the effects of the subtree and this fiber onto the effect")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// list of the parent. The completion order of the children affects the")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// side-effect order.")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n          returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" effectTag "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("effectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Skip both NoWork and PerformedWork tags when creating the effect list.")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// PerformedWork effect is read by React DevTools but shouldn't be committed.")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("effectTag "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" PerformedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("nextEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n          returnFiber"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("lastEffect "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这两段代码的意思就是，将当前Fiber节点的子树上的产生的 "),a("code",[t._v("effectTag")]),t._v(" 链条添加到父节点的 "),a("code",[t._v("firstEffect")]),t._v(" 和 "),a("code",[t._v("lastEffect")]),t._v(" ，然后当前节点如果也有更新的话也添加到父节点的 "),a("code",[t._v("firstEffect")]),t._v(" 和 "),a("code",[t._v("lastEffect")]),t._v(" 中，这样一步一步提交到最顶层，所有的产生了更新的节点就串成了一个链条存在最顶层的Fiber节点的 "),a("code",[t._v("firstEffect")]),t._v("  和 "),a("code",[t._v("lastEffect")]),t._v(" 中，"),a("code",[t._v("firstEffect")]),t._v("  指向第一个，而"),a("code",[t._v("lastEffect")]),t._v(" 指向最后一个，并且由于 "),a("code",[t._v("componentUnitOfWork")]),t._v("是自下而上，自左而又的，所以对于产生更新的节点的存储，同一层级中之前的是排于之后的前面，子节点排于父节点的前面，所以，可以断言，"),a("code",[t._v("componentDidMount")]),t._v(" 生命周期，同一层级的节点中，写在前面的先执行，子节点比父节点先执行。并且观看源码，可以发现 "),a("code",[t._v("commitAllLifeCycles")]),t._v("  的操作是在 "),a("code",[t._v("commitAllHostEffects")]),t._v(" 之后进行的，也就是dom节点的操作已经结束之后，所以这是为什么在 "),a("code",[t._v("componentDidMount")]),t._v("  中可以拿到dom实例的原因。顺便提一句，ref属性也是在这个时候被挂载上的。")]),t._v(" "),a("h3",{attrs:{id:"_1-3-componentdidupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-componentdidupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.3 componentDidUpdate")]),t._v(" "),a("p",[a("code",[t._v("componentDidUpdate")]),t._v(" 其实在代码中与 "),a("code",[t._v("componentDidMount")]),t._v(" 是在同一处被调用的。代码：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("current "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("startPhaseTimer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("finishedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'componentDidMount'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" finishedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" finishedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidMount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPhaseTimer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" prevProps "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" prevState "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("startPhaseTimer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("finishedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'componentDidUpdate'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" finishedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" finishedWork"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("memoizedState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n            prevProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            prevState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__reactInternalSnapshotBeforeUpdate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPhaseTimer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("可以看到，判断了一个 "),a("code",[t._v("current")]),t._v(" 的变量，那么这个 "),a("code",[t._v("current")]),t._v(" 是什么呢？其实react存在一个工作区的概念，就是在操作的时候所有的操作都是在工作区中进行，当操作完成之后再把以前的老的替换成这个工作区，下一次更新又会创建一个工作区。在Fiber对象的属性中有一个 "),a("code",[t._v("alternate")]),t._v(" 属性指向的就是当前工作区的原本的Fiber节点。什么情况下 "),a("code",[t._v("current")]),t._v(" 会为空呢？当节点是第一次渲染的时候，以前没有current就为空，当节点之前已经渲染过了，current指向的就是上一次渲染的Fiber节点。所以这里已经很清晰了，当节点是第一次渲染的时候调用 "),a("code",[t._v("componentDidMount")]),t._v("  不是第一次渲染也就是节点更新的时候调用 "),a("code",[t._v("componentDidUpdate")]),t._v(" 并且传入了上一次渲染时候的props和state。所以，"),a("code",[t._v("componentDidUpdate")]),t._v(" 生命周期也是，同一层级的节点中，写在前面的先执行，子节点比父节点先执行。所以最好不要在 "),a("code",[t._v("componentDidUpdate")]),t._v("  中调用 "),a("code",[t._v("setState")]),t._v(" ，因为应用一旦更新又会触发这个生命周期方法，这个方法又去执行 "),a("code",[t._v("setState")]),t._v("  就会一直处于这个工程中。")]),t._v(" "),a("h3",{attrs:{id:"_1-4-shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-shouldcomponentupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.4 shouldComponentUpdate")]),t._v(" "),a("p",[t._v("这个生命周期优化react应用很重要的一次生命周期方法，可以用它来控制节点这次是否要更新，即使我们触发了 "),a("code",[t._v("setState")]),t._v(" 。这个生命周期在 "),a("code",[t._v("beginWord")]),t._v(" 也就是更新Fiber节点的时候被调用。在 "),a("code",[t._v("beginWord")]),t._v(" 更新 "),a("code",[t._v("classComponent")]),t._v(" 的过程中，会调用到 "),a("code",[t._v("checkShouldComponentUpdate")]),t._v(" 这个方法。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("checkShouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  ctor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  oldProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  newProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  oldState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  nextContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" instance "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("stateNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),t._v(" instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("shouldComponentUpdate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'function'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("startPhaseTimer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'shouldComponentUpdate'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" shouldUpdate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" instance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      newProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      nextContext"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("stopPhaseTimer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" shouldUpdate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ctor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" ctor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("isPureReactComponent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shallowEqual")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shallowEqual")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" newState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("如果当前的"),a("code",[t._v("classComponent")]),t._v(" 实例中有设置  "),a("code",[t._v("shouldComponentUpdate")]),t._v(" 方法的话，就返回这个方法返回的值，在这里也可以看到 "),a("code",[t._v("PureReactComponent")]),t._v(" 的实现原理，如果当前 "),a("code",[t._v("classComponent")]),t._v(" 是一个 "),a("code",[t._v("PureComponent")]),t._v(" 就会浅比较新老props和新老state，就不说具体是怎么比较的了，反正只是做了一层浅了比较。如果两个对象完全相同则不更新，一般情况下也不会出现两个对象完全相同的情况。大多情况下都会比较第一层的属性。如果新对象比老对象多一个属性或者少一个属性，肯定是符合更新要求的。如果是 "),a("code",[t._v("a={value: 1}")]),t._v(" "),a("code",[t._v("b={value: 1}")]),t._v(" 这种，那么实际上对象中的属性是完全一直的也不会更新。如果是 "),a("code",[t._v("a={obj:{}}")]),t._v(" "),a("code",[t._v("b={obj:{}}")]),t._v(" 这种，我们都知道对象是不等于一个对象的，即使他们都是 "),a("code",[t._v("{}")]),t._v(" ，这种情况下不会在往下去比较a.obj和b.obj的值，视为符合更新条件。")]),t._v(" "),a("p",[t._v("很明显可以看到，如果props和state都没有改变的话，就返回false。如果即没有 "),a("code",[t._v("shouldComponentUpdate")]),t._v(" 也没有 "),a("code",[t._v("PureComponent")]),t._v("  那就直接返回了一个true，说明在一般情况下，普通 "),a("code",[t._v("Component")]),t._v(" 每次父组件更新，子组件也会更新。")]),t._v(" "),a("h3",{attrs:{id:"_1-5-componentwillunmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-componentwillunmount","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.5 componentWillUnMount")]),t._v(" "),a("p",[t._v("这也是很熟悉的一个生命周期属性，组件即将被卸载的时候调用。这个生命周期也是在 "),a("code",[t._v("commitRoot")]),t._v(" 阶段被调用，在之前说的 "),a("code",[t._v("commitAllHostEffects")]),t._v("  操作中，如果Fiber对象的 "),a("code",[t._v("effectTap")]),t._v(" 被打上了 "),a("code",[t._v("Deletion")]),t._v(" 也就是删除。就会进入删除节点的逻辑中，"),a("code",[t._v("componentWillUnMount")]),t._v(" 也是在这其中被调用。")]),t._v(" "),a("p",[t._v("当一个节点被删除的时候，其子节点也会被删除。通过看源码，它这个遍历过程也是跟之前更新节点的时候的过程是一样的 。先沿着 Fiber.child 一直找一侧，往下找之前如果是 "),a("code",[t._v("classComponent")]),t._v(" 并且有设置这个方法就先调用。当Fiber.child找到最末尾的时候，就开始找兄弟节点。所以 这个执行的顺序应该是，父节点先执行 "),a("code",[t._v("componentWillUnMount")]),t._v(" 然后是沿着fiber树找 Fiber.child 也就是第一个子节点，然后从下往上找兄弟节点。卸载ref属性也是在这个过程中进行的。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child3 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Child1")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Child2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("比如说一个组件的render是这样，当前组件的 "),a("code",[t._v("componentWillUnMount")]),t._v(" 最先执行，然后是 "),a("code",[t._v("Child1")]),t._v("，然后是 "),a("code",[t._v("Child2")]),t._v(" 最后是 "),a("code",[t._v("Child3")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"_2新生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2新生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" 2新生命周期")]),t._v(" "),a("h3",{attrs:{id:"_2-1-getsnapshotbeforeupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-getsnapshotbeforeupdate","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.1 getSnapshotBeforeUpdate")]),t._v(" "),a("p",[t._v("这个生命周期可能使用的比较少，它的作用就是获取更新前的一个快照，在最近一次渲染输出中被调用。\n首先是在 "),a("code",[t._v("beginWork")]),t._v(" 的时候，如果设置了这个生命周期，就会给节点的 "),a("code",[t._v("effctTag")]),t._v(" 加上 "),a("code",[t._v("Snapshot")]),t._v(" ，然后到了"),a("code",[t._v("commitWork")]),t._v(" 阶段，也是会遍历 effctTag 链条。然后在提交到 DOM 节点 之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate。")]),t._v(" "),a("h3",{attrs:{id:"_2-2-getderivedstatefromprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-getderivedstatefromprops","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.2 getDerivedStateFromProps")]),t._v(" "),a("p",[t._v("这个生命周期在组件第一次挂或组件发生更新的时候都会被触发。在使用的时候只能作为组件的静态方法使用，也就是是说，在这个生命周期中不能访问 "),a("code",[t._v("this")]),t._v(" ，不能通过 "),a("code",[t._v("this.setState")]),t._v(" 去设置 "),a("code",[t._v("state")]),t._v(" 而是返回一个对象用于设置 "),a("code",[t._v("state")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDerivedStateFromProps")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" prevState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在我的理解中这个生命周期是对标废弃的生命周期 "),a("code",[t._v("componentWillReceiveProps")]),t._v("(将要废弃) 的，不同的是，"),a("code",[t._v("componentWillReceiveProps")]),t._v(" 只在组件的更新流程中且"),a("code",[t._v("props")]),t._v("发生改变时才会被调用，而 "),a("code",[t._v("getDerivedStateFromProps")]),t._v(" 无论是组件加载还是更新都会调用。"),a("code",[t._v("componentWillReceiveProps")]),t._v(" 可以访问到 "),a("code",[t._v("this")]),t._v("，可以通过 "),a("code",[t._v("this.setState")]),t._v(" 来设置 "),a("code",[t._v("state")]),t._v(" 的值。 而 "),a("code",[t._v("getDerivedStateFromProps")]),t._v(" 只是返回了一个对象。")]),t._v(" "),a("h2",{attrs:{id:"将要废弃的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将要废弃的生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" 将要废弃的生命周期")]),t._v(" "),a("h3",{attrs:{id:"componentwillreceiveprops"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillreceiveprops","aria-hidden":"true"}},[t._v("#")]),t._v(" componentWillReceiveProps")]),t._v(" "),a("p",[a("code",[t._v("componentWillReceiveProps")]),t._v(" 是将要被废弃的生命周期。 看着意思是当组件的 "),a("code",[t._v("props")]),t._v(" 发生变化时触发的使命周期，但是在实际使用中你会发现，这个触发的时机严格来讲应该是父组件重新render的时候(父组件重新render势必会引发props的改变)。所以使用这个生命周期的时候有时候是会造成死循环的，比如，在 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 里执行了会导致父组件发生更新重新render的情况。我认为这是这个生命周期即将被废弃的其中一个原因。")]),t._v(" "),a("p",[t._v("然而这个生命周期被废弃的更重要的一个原因，应该是，在 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 中是可以进行 "),a("code",[t._v("setState")]),t._v(" 操作的，而现在react16的源码中，使用 "),a("code",[t._v("setState")]),t._v(" 就会为每个 "),a("code",[t._v("Fiber")]),t._v(" 对象创建一个有关于优先级的标志、而在 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 中执行的 "),a("code",[t._v("setState")]),t._v(" 由于本次更新还没有结束，在进入 "),a("code",[t._v("requestWork")]),t._v(" 的时候就会被大打断，所以react在现在还没有完全废弃掉 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 生命周期的时候，在组件更新的代码中 触发完 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 生命周期后执行了 "),a("code",[t._v("processUpdateQueue")]),t._v(" 即重新处理 "),a("code",[t._v("Fiber")]),t._v(" 对象的 "),a("code",[t._v("UpdateQueue")]),t._v(" ，目的就是立即执行 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 的 "),a("code",[t._v("setState")]),t._v(" 添加到 Fiber对象的 "),a("code",[t._v("UpdateQueue")]),t._v(" 中操作。 所以react现在修改了代码，使得"),a("code",[t._v("classComponent")]),t._v("在***更新***的过程中不能在“合理”的使用 "),a("code",[t._v("setState")]),t._v("。")]),t._v(" "),a("p",[t._v("为什么用“合理”这两个字？在 "),a("code",[t._v("classComponent")]),t._v(" 的render方法中，你也可以使用 "),a("code",[t._v("setState")]),t._v(" 方法，但是这样换来的是死循环。所以这是不合理的，而在 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 使用 "),a("code",[t._v("setState")]),t._v(" 只要不触发父组件的更新，就不会引发死循环，但这看起来似乎不可控制，因为没人能保证开发者永远写出正确的代码。")]),t._v(" "),a("h3",{attrs:{id:"componentwillmount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#componentwillmount","aria-hidden":"true"}},[t._v("#")]),t._v(" componentWillMount")]),t._v(" "),a("p",[t._v("这个生命周期在组件是第一次加载，真正挂在到dom树上之前调用。它废弃的原因与 "),a("code",[t._v("componentWillReceiveProps")]),t._v(" 相同，也是因为可以在其中进行 "),a("code",[t._v("setState")]),t._v(" 的操作。")])])}],!1,null,null,null);s.default=e.exports}}]);