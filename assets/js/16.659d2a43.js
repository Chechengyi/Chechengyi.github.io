(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{181:function(t,e,s){"use strict";s.r(e);var n=s(0),r=Object(n.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("关于缓存讲解的文章推荐一篇来自掘金的文章："),s("a",{attrs:{href:"https://juejin.im/post/5eb7f811f265da7bbc7cc5bd",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.im/post/5eb7f811f265da7bbc7cc5bd"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("一直很想学习缓存这一块儿的东西，毕竟前端性能优化缓存在其中占了很大一部分作用。缓存分为两种：强制缓存和协商缓存。看过很多文章讲它们之间的区别，但是没有实战过只知道其意义却不知道怎样去设置，没有实战过也导致记忆总是很模糊，实践才是最好的老师！记录一下我使用nginx服务器学习缓存的过程。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),s("p",[t._v("然后我们浏览器访问 localhost:8080。打开控制台，发现里面有两条请求：")]),t._v(" "),t._m(4),t._v(" "),s("p",[t._v("可以看到第一次访问，两条请求的状态码都是 200。我们点开其中一条请求看看响应头信息：")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._m(14),t._v(" "),t._m(15),t._v(" "),s("p",[t._v("可以看到，此时 html 文件和 js文件都是 304 都是命中协商缓存了。")]),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),t._v(" "),s("p",[t._v("总结一下，正向代理即是客户端代理， 代理客户端, 服务端不知道实际发起请求的客户端。反向代理即是服务端代理，代理服务端, 客户端不知道实际提供服务的服务端。 借用在其他文章中看到的总结的特别好的一句话：正向代理是找黄牛买票，反向代理是租房的中介。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"nginx设置资源缓存实战"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx设置资源缓存实战","aria-hidden":"true"}},[this._v("#")]),this._v(" nginx设置资源缓存实战")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"初探"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#初探","aria-hidden":"true"}},[this._v("#")]),this._v(" 初探")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("首先我在 "),s("em",[t._v("nginx")]),t._v(" 的根目录下新建了一个 "),s("code",[t._v("index.html")]),t._v(" 文件以及 "),s("code",[t._v("index.js")]),t._v(" 文件。此时 "),s("code",[t._v("nginx")]),t._v("  的配置文件是长这个样子的：")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-nginx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-nginx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("listen")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server_name")]),t._v("  localhost"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Volumes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("myFile"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("nginx_root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("htm"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e075f3bcd72de4?w=1017&h=85&f=png&s=20843",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e075f3bdc4481b?w=633&h=199&f=png&s=37363",alt:""}})])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("可以看到，响应头中给我们携带了 "),s("code",[t._v("Etag")]),t._v(" 以及 "),s("code",[t._v("Last-Modified")]),t._v(" 信息。这就是协商缓存所使用的字段嘛。看来 "),s("em",[t._v("nginx")]),t._v(" 已经默认给我们使用了缓存。那我们在不修改 html文件以及js文件的基础上再次去刷新页面验证一下，命中协商缓存的话，状态码应该给我们返回 "),s("code",[t._v("304 Not Modified")]),t._v(" 。我刷新了几次去观察http请求的状态码。html文件每次都是返回的 304。但是 js 文件在最初是 304 后面却变成了 "),s("code",[t._v("200 OK (from memory cache)")]),t._v(" 。也就是说每一次html文件都是命中了协商缓存，而js文件都是命中了强缓存(强缓存的优先级是高于协商缓存的)。为什么会出现这样的情况呢，我百度一下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("为什么有的缓存是 200 OK (from cache)，有的缓存是 304 Not Modified 呢？很简单，看是否移除了 Entity Tag。移除了，就总是 200 OK (from cache)。没有移除，就两者会交替出现。")]),this._v(" "),e("p",[this._v("那么，两者触发的时机有什么区别呢？200 OK (from cache) 是直接点击链接访问，输入网址按回车访问也能触发；而 304 Not Modified 是刷新页面时触发，或是设置了强缓存、但 Entity Tags 没有移除时触发。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对照我的例子，我是这样理解的："),e("code",[this._v("index.html")]),this._v(" 文件刷新页面命中协商缓存返回了 304，而 js 文件是在 index.html 文件中链接引入的，所以命中强缓存 200 OK (from cache) 。为了验证我的想法，我用在地址栏直接访问了 "),e("code",[this._v("index.js")]),this._v(" 文件。地址栏键入：localhost:8080/index.js，此时的确是返回了 304 给我了，在来看一下此时的请求头：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e075f3beded97b?w=769&h=294&f=png&s=78103",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("可以看到此时 "),e("code",[this._v("Cache-Control")]),this._v(" 给的是max-age=0；然后也携带上了协商缓存的相关参数。看来在浏览器是刷新操作的时候就会携带上 "),e("code",[this._v("Cache-Control:max-age=0")]),this._v(" 以此来避免命中强缓存。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"nginx禁用强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx禁用强缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" nginx禁用强缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在试试 "),e("em",[this._v("nginx")]),this._v(" 禁用强缓存之后会发生什么效果。修改 "),e("em",[this._v("nginx")]),this._v(" 配置文件：")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"language-nginx extra-class"},[s("pre",{pre:!0,attrs:{class:"language-nginx"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("listen")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server_name")]),t._v("  localhost"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Volumes"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("myFile"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("nginx_root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("htm"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add_header")]),t._v(" Cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control no"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("cache"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 为 public可以被任何对象缓存，private只能针对个人用户，而不能被代理服务器缓存")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("add_header")]),t._v(" Cache"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control private"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("修改完 "),e("em",[this._v("nginx")]),this._v(" 配置文件之后我们重启一下 "),e("em",[this._v("nginx")]),this._v(" 服务器。此时在访问 localhost:8080")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e075f3be74f974?w=969&h=250&f=png&s=54580",alt:""}})])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("blockquote",[s("p",[s("strong",[t._v("Cache-Control")]),t._v("："),s("strong",[t._v("no-store")])]),t._v(" "),s("p",[t._v("禁止一切缓存（这个才是响应不被缓存的意思）。缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。")]),t._v(" "),s("p",[s("strong",[t._v("Cache-Control：no-cache")])]),t._v(" "),s("p",[t._v("强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误以为是响应不被缓存。实际上Cache-Control: no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("其实将 "),s("strong",[t._v("Cache-Control")]),t._v(" 设置为 "),s("strong",[t._v("no-store")]),t._v(" 才是真正的不被缓存的意思，那在修改一下 "),s("em",[t._v("nginx")]),t._v(" 文件将 "),s("strong",[t._v("Cache-Control")]),t._v(" 设置为 "),s("strong",[t._v("no-store")]),t._v(" 看看会发生什么。此时再次刷新浏览器。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e075f3bfedd272?w=1024&h=253&f=png&s=56460",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("可以看到，修改完 "),e("em",[this._v("nginx")]),this._v(" 的配置文件之后，除了第一次是304(这次访问浏览器才刚刚接收到 no-store的信息，请求头上还是携带了缓存相关信息) 外，剩下的几次刷新页面都是返回 200了。既没有命中强缓存、也没有命中协商缓存。在看一下 "),e("code",[this._v("index.js")]),this._v(" 文件的 http 头信息。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/10/26/16e075f3bf81d64a?w=1166&h=350&f=png&s=114228",alt:""}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这里的图我没有截完整，其实响应头中还包含了"),e("strong",[this._v("Cache-Control: no-store")]),this._v("。可以看到，在"),e("strong",[this._v("Cache-Control: no-store")]),this._v(" 的加持下，即使在响应头中服务请返回了协商缓存的参数，但是在浏览器在请求资源的时候，并没有带上缓存相关的参数了，所以，现在没有缓存了，既不会命中强缓存，也不会命中协商缓存，每一次http请求的资源都是从服务器上返回的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"结语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[this._v("#")]),this._v(" 结语")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这次的探索到现在就结束了，其实就是我一次学习的记录吧。实践了一次之后确实对缓存有了更清晰的理解和认知，果真实践出真知。后续打算还会记录一篇在现在前端使用 React.js 或者 Vue.js 等框架打包之后前端资源如何利用 "),e("em",[this._v("nginx")]),this._v(" 做部署还有配置相关缓存的文章，到时候在看有没有记录下来的意义把。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展","aria-hidden":"true"}},[this._v("#")]),this._v(" 扩展")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("平时我们在谈论 "),e("code",[this._v("nginx")]),this._v(" 的时候，总是会说到 "),e("code",[this._v("nginx")]),this._v(" "),e("strong",[this._v("反向代理")]),this._v("，那就会自然而然的产生一个疑问， 有没有正向代理呢？它与反向代理的区别是什么？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("比如说，我现在想要使用谷歌搜索引擎，但是由于在国内的原因，直接访问是访问不到的。这时候我们就可以通过一个代理服务器，请求发送到代理服务器，代理服务器再去访问谷歌取到数据在返回给我们，这样就能访问到谷歌了。\n"),e("img",{attrs:{src:"https://s1.ax1x.com/2020/10/30/BtR8c4.png",alt:"正向代理"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在看反向代理，反向代理实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。\n"),e("img",{attrs:{src:"https://s1.ax1x.com/2020/10/30/BtW3IP.png",alt:"反向代理"}}),this._v("\n反向代理的作用：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网")]),this._v(" "),e("li",[this._v("负载均衡，通过反向代理服务器来优化网站的负载")])])}],!1,null,null,null);e.default=r.exports}}]);